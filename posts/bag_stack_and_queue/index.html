<!DOCTYPE html>
<html lang="zh-cn">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="Bag, Stack and Queue的构造与运用|Algorithms, Part1|第二周">
<meta itemprop="description" content="引言 记录一下刷Coursera上《Algorithms, Part1》课程的所学内容。主要包括复现一些课上经典的数据结构与算法（C&#43;&#43;），以及"><meta itemprop="datePublished" content="2022-06-02T21:32:25&#43;08:00" />
<meta itemprop="dateModified" content="2022-06-02T21:32:25&#43;08:00" />
<meta itemprop="wordCount" content="5784">
<meta itemprop="keywords" content="算法,数据结构," /><meta property="og:title" content="Bag, Stack and Queue的构造与运用|Algorithms, Part1|第二周" />
<meta property="og:description" content="引言 记录一下刷Coursera上《Algorithms, Part1》课程的所学内容。主要包括复现一些课上经典的数据结构与算法（C&#43;&#43;），以及" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ironhao-github-io.pages.dev/posts/bag_stack_and_queue/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-02T21:32:25&#43;08:00" />
<meta property="article:modified_time" content="2022-06-02T21:32:25&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Bag, Stack and Queue的构造与运用|Algorithms, Part1|第二周"/>
<meta name="twitter:description" content="引言 记录一下刷Coursera上《Algorithms, Part1》课程的所学内容。主要包括复现一些课上经典的数据结构与算法（C&#43;&#43;），以及"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Bag, Stack and Queue的构造与运用|Algorithms, Part1|第二周</title>
	<link rel="stylesheet" href="https://ironhao-github-io.pages.dev/css/style.min.eac77496566fd7d5768fd650ddb0b2b181ca6a2d7c5fdd6fe6b8ba4bf47e566f.css" integrity="sha256-6sd0llZv19V2j9ZQ3bCysYHKai18X91v5ri6S/R+Vm8=" crossorigin="anonymous">
	<style type="text/css">@font-face{
    font-family: 'Noto Sans CJK';
    font-weight: 200;
    font-style: normal;
    font-stretch: normal;
    font-display: swap;
    src: url('https://ironhao-github-io.pages.dev/fonts/NotoSansCJK-Regular-1.otf') format('opentype'),
         url('https://ironhao-github-io.pages.dev/fonts/NotoSansCJK-Thin-2.otf') format('opentype'),
         url('https://ironhao-github-io.pages.dev/fonts/NotoSansCJK-Light-3.otf') format('opentype'),
         url('https://ironhao-github-io.pages.dev/fonts/NotoSansCJK-DemiLight-4.otf') format('opentype'),
         url('https://ironhao-github-io.pages.dev/fonts/NotoSansCJK-Medium-5.otf') format('opentype'),
         url('https://ironhao-github-io.pages.dev/fonts/NotoSansCJK-Bold-6.otf') format('opentype'),
         url('https://ironhao-github-io.pages.dev/fonts/NotoSansCJK-Black-7.otf') format('opentype');
       
}</style>

	<link rel="stylesheet" href="/css/search.min.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery-modal/0.9.1/jquery.modal.min.css" />

	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.min.js"></script>

	
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-modal/0.9.1/jquery.modal.min.js"></script>

	<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
	<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>


 	
	<script src= "/js/search.js" type="text/javascript"></script>
	
</head>

<body id="page">

	
	<a href="#ex1" rel="modal:open"><i class="fas fa-search fa-fw"></i></a>
	
	
	
	<header id="site-header" class="animated slideInUp">

		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://ironhao-github-io.pages.dev/">IronHao</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://ironhao-github-io.pages.dev/posts/">Posts</a>
				<a href="https://ironhao-github-io.pages.dev/pixelArt/">Pixel Art</a>
				<a href="https://ironhao-github-io.pages.dev/about-hugo/">About</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="https://zjut_yangtiehao@outlook.com" target="_blank" rel="noopener me" title="Email"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a><a href="https://github.com/IronHao" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">

		<ul>
			<li><a href="https://ironhao-github-io.pages.dev/posts/">Posts</a></li>
			<li><a href="https://ironhao-github-io.pages.dev/pixelArt/">Pixel Art</a></li>
			<li><a href="https://ironhao-github-io.pages.dev/about-hugo/">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Jun 2, 2022</span></div>
				<h1>Bag, Stack and Queue的构造与运用|Algorithms, Part1|第二周</h1>
			</header>
			<div class="content">
				<h1 id="引言">引言<a href="#引言" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<p>记录一下刷Coursera上《Algorithms, Part1》课程的所学内容。主要包括复现一些课上经典的数据结构与算法（C++），以及每周课程作业的部分（Java）。如有错误之处，欢迎纠正。</p>
<p>对应的Github链接：<a href="https://github.com/IronHao/MyAlgorithmBook">IronHao/MyAlgorithmBook (github.com)</a></p>
<h1 id="正文">正文<a href="#正文" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<p>本周内容比较多，分两篇来总结。这是第一部分，主要包含<code>Bag</code>, <code>Stack</code> and <code>Queue</code>的内容。</p>
<h2 id="课程内容">课程内容<a href="#课程内容" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p><code>Bag</code>, <code>Stack</code> and <code>Queue</code>是最基础的三个数据结构，我们后续更复杂的算法和数据结构都基于这几个数据结构。</p>
<p>在具体学习了解各个数据结构之前，书本上给我们指明了数据结构的三个最优设计目标：</p>
<ol>
<li>它可以处理任意类型的数据；</li>
<li>所需的空间总是和集合的大小成正比；</li>
<li>操作所需的时间总是和集合的大小无关。</li>
</ol>
<p>这次在代码实现上，我使用模板类（template）来实现泛型的效果[为了实现目标1]。同时为了代码的整洁，我将头文件（.h）与源文件（.cpp）分离。</p>
<blockquote>
<p>这中间还遇到了一些小问题，具体可以<a href="https://www.ironhao.top/posts/undefined_reference_to_in_cplusplus/">查看这边</a>。</p>
<p>另外因为我使用偷懒的办法（再导入<code>.cpp</code>文件）去解决这个问题，为了防止重复编译，要在每个文件开头写上<code>#pragma once</code>保证只执行一次编译。</p>
</blockquote>
<p>另外，为了简化内容，我并没有对一些极端情况进行异常处理，如栈为空时尝试从栈顶弹出元素，正常应该抛出一个栈为空的异常报错，然而我选择默认弹出一个<code>T()</code>的返回值。</p>
<p>接下来让我们逐个看一看。</p>
<h3 id="node">Node<a href="#node" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>因为在这里我会分别使用**链式存储（链表）<strong>和</strong>顺序存储（数组）*<em>两种方法去实现这几个数据结构</em>（Bag仅用链表，因为数组实现感觉也没什么特别的）*。所以我们需要先实现一下链表中的这个结点类<code>Node</code>。</p>
<blockquote>
<p>顺带总结下链表和数组各自的优劣：（来自书本）</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td>通过索引可以直接访问任意元素</td>
<td>在初始化时就需要知道元素的数量</td>
</tr>
<tr>
<td>链表</td>
<td>使用的空间大小和元素数量成正比</td>
<td>需要通过引用访问任意元素（存引用需要增加内存开销）</td>
</tr>
</tbody>
</table>
</blockquote>
<p>这个数据结构应该包含两个基本的变量：</p>
<ul>
<li><code>T _val</code>：一个T类型的值。</li>
<li><code>Node&lt;T&gt;* _next</code>：一个指向下一个结点的指针，没有则设为<code>nullptr</code>（空）。</li>
</ul>
<p>大致如图所示：</p>
<p><img src="https://s2.loli.net/2022/06/05/IwnBWM5jeaX1CPF.png" alt=""></p>
<p>实现代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Node.h */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cm">/* The one node in Linked-list */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Node</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">T</span> <span class="n">_val</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_next</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Node</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">);</span>
    <span class="n">Node</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">next</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Node</span><span class="p">();</span>

    <span class="cm">/* Get methods */</span>
    <span class="n">T</span> <span class="nf">getVal</span><span class="p">();</span>
    <span class="n">Node</span><span class="o">*</span> <span class="nf">getNext</span><span class="p">();</span>
    
    <span class="cm">/* Set methods */</span>
    <span class="kt">void</span> <span class="nf">setVal</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">setNext</span><span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">next</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Node.cpp */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;Node.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Node</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">setVal</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">setNext</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Node</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">setVal</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">setNext</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">Node</span><span class="p">()</span> <span class="p">{};</span>

<span class="cm">/* Get methods */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">getVal</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_val</span><span class="p">;</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">getNext</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_next</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Set methods */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">setVal</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">_val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
    
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">setNext</span><span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span> <span class="n">_next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><h3 id="bag">Bag<a href="#bag" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>背包（Bag）是一种<strong>不支持从中删除元素</strong>的集合数据类型，同时，背包里的元素也<strong>不存在确定的拿取（访问）顺序</strong>。</p>
<p>它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素，且这些元素的处理顺序应该是不重要的。</p>
<p>这个数据结构应该包含以下的几个基本方法：</p>
<ul>
<li><code>void add(T val)</code>：将一个元素添加到包中。</li>
<li><code>bool isEmpty()</code>：判断包是否为空。</li>
<li><code>int size()</code>：返回背包中的元素数量。</li>
<li><code>T* elements()</code>：返回一个装有背包中所有元素的数组。</li>
</ul>
<p>因为背包并没有明确它的访问顺序，在<code>add()</code>中的添加位置也可以任意。考虑到我这边是使用链表来实现，所以我会在链表头部插入新节点，这样每次添加的时间复杂度为常数$O(1)$，减少开销。<code>elements()</code>的话，我选择按照链表的顺序从头逐个读取并存入数组。</p>
<p>实现代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Bag.h */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;Node.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;Node.cpp&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cm">/* 
</span><span class="cm"> * Bag data structure, no specific store way, here we use linked-list to store the data.
</span><span class="cm"> * It has only add() method, no remove() method.
</span><span class="cm"> * The element in bag has no specific order.
</span><span class="cm"> */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Bag</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_size</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Bag</span><span class="p">();</span>
    <span class="o">~</span><span class="n">Bag</span><span class="p">();</span>

    <span class="cm">/* Insert in the head, no need to traverse, time complexity: O(1) */</span> 
    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">);</span>

    <span class="cm">/* Return whether the bag is empty or not */</span>
    <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">();</span>

    <span class="cm">/* Return the number of elements in bag */</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="p">();</span>

    <span class="cm">/* Store the value in array and return */</span>
    <span class="n">T</span><span class="o">*</span> <span class="nf">elements</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Bag.cpp */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;Bag.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Bag</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">_head</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">Bag</span><span class="p">()</span> <span class="p">{}</span>

<span class="cm">/* Insert in the head, no need to traverse, time complexity: O(1) */</span> 
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">setNext</span><span class="p">(</span><span class="n">_head</span><span class="p">);</span>
    <span class="n">_head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">_size</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return whether the bag is empty or not */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isEmpty</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Return the number of elements in bag */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Store the value in array and return */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">*</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">elements</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">_size</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">_head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ans</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">getVal</span><span class="p">();</span> 
        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><h3 id="stack">Stack<a href="#stack" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>栈（Stack），或者叫做下压栈，是一种<strong>基于后进先出（LIFO, Last In Frist Out）策略</strong>的集合类型。</p>
<p>生活中电子邮箱的默认排序（最新的在最上面），以及浏览器的回退按钮等，都基于栈这种后进先出的策略实现。</p>
<p>它默认最新的（刚放到栈顶的）拥有最高的优先级。</p>
<p><img src="https://s2.loli.net/2022/06/05/TX2sJCSGdAqkxBE.png" alt=""></p>
<p>这个数据结构应该包含以下的几个基本方法：</p>
<ul>
<li><code>void push(T item)</code>：将一个元素添加到栈顶。</li>
<li><code>T pop()</code>：弹出（返回并删除）栈顶的元素。</li>
<li><code>T top()</code>：返回栈顶的元素，不删除。</li>
<li><code>bool isEmpty()</code>：查看栈是否为空，为空返回<code>true</code>，否则返回<code>false</code>。</li>
<li><code>int count()</code>：返回栈内的元素个数。</li>
</ul>
<p>栈这边的话既可以使用链式存储，也可以使用顺序存储。对于这两种，分别有一些细节需要考虑：</p>
<ul>
<li>
<p>对于<u>链式存储</u>，我们只需要维护一个指向栈顶元素的指针和元素总数的<code>Int</code>型变量即可。元素总数没啥好说，<code>push</code>+1，<code>pop</code>-1即可。栈顶指针的话，我们将其认为为链表头部，每次我们都在头部添加一个新的，删除则是将指针指向下一个然后删除原先的头指针即可。</p>
</li>
<li>
<p>对于<u>顺序存储</u>，我们只需要维护元素总数的<code>Int</code>型变量即可，数组内非空的最后一个元素就是我们的栈顶。关键就在于<strong>数组大小的动态更改</strong>，因为数组本身大小在分配内存时就限定死了，要想改变大小，只能重新分配一个新的数组，并将原先的值逐个复制过去，这是一个比较大的开销，因为需要遍历整个数组（时间复杂度$O(n)$）。我们这里采取的策略是：</p>
<ul>
<li>当数组满了，我们将数组容量翻倍（即$*2$)，并将原来的数据转移到新数组中；</li>
<li>当数组内元素数量减到数组容量的$\frac{1}{4}$时，我们将数组容量减半（即$\frac{1}{2}$）。</li>
</ul>
<p>这是一种比较高效的做法，具体证明就不展开了。</p>
</li>
</ul>
<p>实现代码如下：（<code>ArrayStack</code>表示使用顺序存储，<code>LinkedListStack</code>表示使用链式存储）</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* ArrayStack.h */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cm">/* 
</span><span class="cm"> * Stack data structure, array implementation. FILO.
</span><span class="cm"> */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ArrayStack</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">_arr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_count</span><span class="p">;</span>

    <span class="cm">/* Return whether the stack is full or not */</span>
    <span class="kt">bool</span> <span class="nf">isFull</span><span class="p">();</span>
    <span class="cm">/* Resize the stack to the &#39;newSize&#39; */</span>
    <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="kt">int</span> <span class="n">newSize</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">ArrayStack</span><span class="p">();</span>
    <span class="o">~</span><span class="n">ArrayStack</span><span class="p">();</span>

    <span class="cm">/* Push the &#39;item&#39; to the top of the stack */</span>
    <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">);</span>
    <span class="cm">/* Pop(delete) and return the item in the top of the stack */</span>
    <span class="n">T</span> <span class="nf">pop</span><span class="p">();</span>
    <span class="cm">/* Get the item in the top of the stack, no delete */</span>
    <span class="n">T</span> <span class="nf">top</span><span class="p">();</span>
    <span class="cm">/* Return whether the stack is empty or not */</span>
    <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">();</span>
    <span class="cm">/* Return the size (allocate memory) of the stack */</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="p">();</span>
    <span class="cm">/* Return the number of items in the stack */</span>
    <span class="kt">int</span> <span class="nf">count</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* ArrayStack.cpp */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;ArrayStack.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">ArrayStack</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">_arr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">_size</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">ArrayStack</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">_arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return whether the stack is full or not */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isFull</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span> <span class="o">==</span> <span class="n">_count</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Resize the stack to the &#39;newSize&#39; */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">resize</span><span class="p">(</span><span class="kt">int</span> <span class="n">newSize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">tempArr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">newSize</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">tempArr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">_arr</span><span class="p">;</span>
    <span class="n">_arr</span> <span class="o">=</span> <span class="n">tempArr</span><span class="p">;</span>
    <span class="n">_size</span> <span class="o">=</span> <span class="n">newSize</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Push the &#39;item&#39; to the top of the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Resize the array(Double the size of array) if the stack is full
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">isFull</span><span class="p">())</span>
        <span class="n">resize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
    <span class="c1">// Push the item
</span><span class="c1"></span>    <span class="n">_arr</span><span class="p">[</span><span class="n">_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Pop(delete) and return the item in the top of the stack. Return nullptr if the stack is empty */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Pop the item
</span><span class="c1"></span>    <span class="n">T</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_arr</span><span class="p">[</span><span class="o">--</span><span class="n">_count</span><span class="p">];</span>
    <span class="c1">// Resize the array(halve the size) if the count is one-quarter full
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="p">()</span> <span class="o">==</span> <span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">resize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the item in the top of the stack, no delete. Return nullptr if the stack is empty */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">top</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">T</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_arr</span><span class="p">[</span><span class="n">_count</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> 
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span> 
<span class="p">}</span>

<span class="cm">/* Return whether the stack is empty or not */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isEmpty</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Return the size (allocate memory) of the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Return the number of items in the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">count</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* LinkedListStack.h */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;Node.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;Node.cpp&#34;</span><span class="cp">
</span><span class="cp"></span>

<span class="cm">/* 
</span><span class="cm"> * Stack data structure, linked-list implementation. FILO.
</span><span class="cm"> */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">LinkedListStack</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="cm">/* data */</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_top</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_count</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">LinkedListStack</span><span class="p">();</span>
    <span class="o">~</span><span class="n">LinkedListStack</span><span class="p">();</span>

    <span class="cm">/* Push the &#39;item&#39; to the top of the stack */</span>
    <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">);</span>
    <span class="cm">/* Pop(delete) and return the item in the top of the stack */</span>
    <span class="n">T</span> <span class="nf">pop</span><span class="p">();</span>
    <span class="cm">/* Get the item in the top of the stack, no delete */</span>
    <span class="n">T</span> <span class="nf">top</span><span class="p">();</span>
    <span class="cm">/* Return whether the stack is empty or not */</span>
    <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">();</span>
    <span class="cm">/* Return the number of items in the stack */</span>
    <span class="kt">int</span> <span class="nf">count</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* LinkedListStack.cpp */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;LinkedListStack.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">LinkedListStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">LinkedListStack</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">_top</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">LinkedListStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">LinkedListStack</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">delete</span> <span class="n">_top</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Push the &#39;item&#39; to the top of the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">LinkedListStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="n">temp</span><span class="o">-&gt;</span><span class="n">setNext</span><span class="p">(</span><span class="n">_top</span><span class="p">);</span>
    <span class="n">_top</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="n">_count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Pop(delete) and return the item in the top of the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">LinkedListStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_top</span><span class="o">-&gt;</span><span class="n">getVal</span><span class="p">();</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">_top</span><span class="p">;</span>
        <span class="n">_top</span> <span class="o">=</span> <span class="n">_top</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
        <span class="k">delete</span> <span class="n">temp</span><span class="p">;</span>
        <span class="n">_count</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the item in the top of the stack, no delete */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">LinkedListStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">top</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_top</span><span class="o">-&gt;</span><span class="n">getVal</span><span class="p">();</span>
    <span class="k">else</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return whether the stack is empty or not */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">LinkedListStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isEmpty</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Return the number of items in the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">LinkedListStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">count</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><h3 id="queue">Queue<a href="#queue" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>队列（Queue），或者叫做先进先出队列，是一种基于先进先出（FIFO, First In First Out）策略的集合类型。</p>
<p>它就像我们生活中排队一样，遵从先来后到的原则，认为最早来的拥有最高的优先级。</p>
<p>通过使用队列，我们可以在保存元素的同时保存它们的相对顺序，即让它们的入列顺序与出列顺序保持一致（栈则刚好相反，为逆序）。</p>
<p><img src="https://s2.loli.net/2022/06/05/4tFNep1XKqU2Jag.png" alt=""></p>
<p>这个数据结构应该包含以下的几个基本方法：</p>
<ul>
<li><code>void enqueue(T item)</code>：将一个元素添加到队尾。</li>
<li><code>T dequeue()</code>：弹出（返回并删除）队头的元素。</li>
<li><code>T first()</code>：返回队头的元素，不删除。</li>
<li><code>T last()</code>：返回队尾的元素，不删除。</li>
<li><code>bool isEmpty()</code>：查看队列是否为空，为空返回<code>true</code>，否则返回<code>false</code>。</li>
<li><code>int count()</code>：返回队列内的元素个数。</li>
</ul>
<p>同样，队列这边的话也既可以使用链式存储，也可以使用顺序存储。对于这两种，分别有一些细节需要考虑：</p>
<ul>
<li>
<p>对于<u>链式存储</u>，我们只需要维护两个指针（一个指向队头的元素，一个指向队尾的元素）和元素总数的<code>Int</code>型变量即可。元素总数没啥好说，<code>enqueue</code>+1，<code>dequeue</code>-1即可。指针的话就是简单的在删除和添加操作时更新头和尾指针即可。正常情况下，<code>enqueue</code>只用更新队尾指针，<code>dequeue</code>只用更新队头指针。但要注意为空的边界条件（从一个元素变为零个/从零个变为一个），此时两个指针都需要维护。</p>
</li>
<li>
<p>对于<u>顺序存储</u>，我们有两种选择：</p>
<ul>
<li>维护一个指向队头的下标+元素总数的<code>Int</code>型变量，队尾由<code>队头+元素总数-1</code>得出。</li>
<li>维护一个指向队头的下标+一个指向队尾的下标，元素总数由<code>队尾-队头+1</code>得出。</li>
</ul>
<p>在这里我选择第一种。另外，为了充分利用空间，我们将数组理解为一个<strong>环</strong>（即对于大小为$n$的数组$arr$，最后一个数组元素$arr[n-1]$的下一个元素为$arr[0]$)。所以我们这里要用到取余<code>%</code>来实现，具体见代码。</p>
</li>
</ul>
<p>实现代码如下：（<code>ArrayQueue</code>表示使用顺序存储，<code>LinkedListQueue</code>表示使用链式存储）</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* ArrayQueue.h */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cm">/* 
</span><span class="cm"> * Queue data structure, linked-list implementation. FIFO.
</span><span class="cm"> */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ArrayQueue</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">_arr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_count</span><span class="p">;</span>

    <span class="cm">/* Return whether the queue is full or not */</span>
    <span class="kt">bool</span> <span class="nf">isFull</span><span class="p">();</span>
    <span class="cm">/* Resize the queue to the &#39;newSize&#39; */</span>
    <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="kt">int</span> <span class="n">newSize</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ArrayQueue</span><span class="p">();</span>
    <span class="o">~</span><span class="n">ArrayQueue</span><span class="p">();</span>

    <span class="cm">/* Insert a new item onto queue(tail of the queue) */</span>
    <span class="kt">void</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">);</span>
    <span class="cm">/* Remove and return the item least recently added(head of the queue) */</span>
    <span class="n">T</span> <span class="nf">dequeue</span><span class="p">();</span>
    <span class="cm">/* Return the item least recently added without removing */</span>
    <span class="n">T</span> <span class="nf">first</span><span class="p">();</span>
    <span class="cm">/* Return the item latest recently added without removing */</span>
    <span class="n">T</span> <span class="nf">last</span><span class="p">();</span>
    <span class="cm">/* Return whether the queue is empty or not */</span>
    <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">();</span>
    <span class="cm">/* Return the size (allocate memory) of the queue */</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="p">();</span>
    <span class="cm">/* Return the number of items in queue */</span>
    <span class="kt">int</span> <span class="nf">count</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* ArrayStack.cpp */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;ArrayStack.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">ArrayStack</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">_arr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">_size</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">ArrayStack</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">_arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return whether the stack is full or not */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isFull</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span> <span class="o">==</span> <span class="n">_count</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Resize the stack to the &#39;newSize&#39; */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">resize</span><span class="p">(</span><span class="kt">int</span> <span class="n">newSize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">tempArr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">newSize</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">tempArr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">_arr</span><span class="p">;</span>
    <span class="n">_arr</span> <span class="o">=</span> <span class="n">tempArr</span><span class="p">;</span>
    <span class="n">_size</span> <span class="o">=</span> <span class="n">newSize</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Push the &#39;item&#39; to the top of the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Resize the array(Double the size of array) if the stack is full
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">isFull</span><span class="p">())</span>
        <span class="n">resize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
    <span class="c1">// Push the item
</span><span class="c1"></span>    <span class="n">_arr</span><span class="p">[</span><span class="n">_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Pop(delete) and return the item in the top of the stack. Return nullptr if the stack is empty */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Pop the item
</span><span class="c1"></span>    <span class="n">T</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_arr</span><span class="p">[</span><span class="o">--</span><span class="n">_count</span><span class="p">];</span>
    <span class="c1">// Resize the array(halve the size) if the count is one-quarter full
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="p">()</span> <span class="o">==</span> <span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">resize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the item in the top of the stack, no delete. Return nullptr if the stack is empty */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">top</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">T</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_arr</span><span class="p">[</span><span class="n">_count</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> 
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span> 
<span class="p">}</span>

<span class="cm">/* Return whether the stack is empty or not */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isEmpty</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Return the size (allocate memory) of the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Return the number of items in the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">count</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* LinkedListQueue.h */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;Node.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;Node.cpp&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 
</span><span class="cm"> * Queue data structure, linked-list implementation. FIFO.
</span><span class="cm"> */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">LinkedListQueue</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_first</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_last</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_count</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">LinkedListQueue</span><span class="p">();</span>
    <span class="o">~</span><span class="n">LinkedListQueue</span><span class="p">();</span>

    <span class="cm">/* Insert a new item onto queue(tail of the queue) */</span>
    <span class="kt">void</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">);</span>
    <span class="cm">/* Remove and return the item least recently added(head of the queue) */</span>
    <span class="n">T</span> <span class="nf">dequeue</span><span class="p">();</span>
    <span class="cm">/* Return the item least recently added without removing */</span>
    <span class="n">T</span> <span class="nf">first</span><span class="p">();</span>
    <span class="cm">/* Return the item latest recently added without removing */</span>
    <span class="n">T</span> <span class="nf">last</span><span class="p">();</span>
    <span class="cm">/* Return whether the queue is empty or not */</span>
    <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">();</span>
    <span class="cm">/* Return the number of items in queue */</span>
    <span class="kt">int</span> <span class="nf">count</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* LinkedListQueue.cpp */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;LinkedListQueue.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">LinkedListQueue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">_first</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">_last</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">LinkedListQueue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">delete</span> <span class="n">_first</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">_last</span><span class="p">;</span>
<span class="p">}</span>
    
<span class="cm">/* Insert a new item onto queue(tail of the queue) */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">enqueue</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">_last</span><span class="o">-&gt;</span><span class="n">setNext</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
        <span class="n">_last</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">_last</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_first</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
            <span class="n">_first</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">_count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
    
<span class="cm">/* Remove and return the item least recently added(head of the queue) */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">dequeue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_first</span><span class="o">-&gt;</span><span class="n">getVal</span><span class="p">();</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">_first</span><span class="p">;</span>
        <span class="n">_first</span> <span class="o">=</span> <span class="n">_first</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
        <span class="k">delete</span> <span class="n">temp</span><span class="p">;</span>
        <span class="n">_count</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return the item least recently added without removing */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">first</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_first</span><span class="o">-&gt;</span><span class="n">getVal</span><span class="p">();</span>
    <span class="k">else</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* Return the item latest recently added without removing */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>    
<span class="n">T</span> <span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">last</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_last</span><span class="o">-&gt;</span><span class="n">getVal</span><span class="p">();</span>
    <span class="k">else</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return whether the queue is empty or not */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isEmpty</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_first</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Return the number of items in queue */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">count</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><h3 id="应用">应用<a href="#应用" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>应用方面，课程中主要重点讲解了Dijkstra的双栈算术表达式求值算法。该算法使用了使用了两个栈，一个存储值，一个存储运算符。它仅对未省略括号的算术表达式有效。且我们为了简化，只考虑二元运算符。它主要要处理下列四种情况：</p>
<ul>
<li>对于操作数（值），它将其压入到操作数（值）栈中；</li>
<li>对于运算符，它将其压入到运算符栈中；</li>
<li>对于左括号，虽然为运算符，我们将其忽略；</li>
<li>对于右括号，我们从运算符栈中弹出栈顶运算符，并从值栈中，弹出栈顶两个元素（只考虑二元运算符），并根据弹出的运算符，对两个弹出的值进行相应的计算操作。</li>
</ul>
<p>这里有几个细节需要注意：</p>
<ul>
<li>因为我们是从左到右扫描，逐个读取处理字符串。所以对于弹出的两个值元素，先弹出的应该是运算符右侧的值（后压入），后弹出的则是运算符左侧的值（先压入）。</li>
<li>课程中是逐个读取字符串，一个字符串代表一个值/运算符。我改为直接输入整行算数表达式。则需要逐个字符处理，对应的，为了判断输入的值是否完整（比如我输入了98,要判断是98而不是9），我们要往前看一位，若接下来一位仍为数字，则将当前结果×10并继续读下一位，若不是，则表明值已经读取完整，将其压入值栈中。</li>
</ul>
<p>具体代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* ArithmeticExpressionUsingStack.cpp */</span>

<span class="cp">#include</span> <span class="cpf">&#34;ArrayStack.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;ArrayStack.cpp&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="cm">/*
</span><span class="cm"> *  Dijkstra&#39;s two-stack arithmetic expression evaluation.
</span><span class="cm"> *  One stack for operator, another stack for value.
</span><span class="cm"> *  ・Value: push onto the value stack.
</span><span class="cm"> *  ・Operator: push onto the operator stack.
</span><span class="cm"> *  ・Left parenthesis: ignore.
</span><span class="cm"> *  ・Right parenthesis: pop operator and two values; push the result of applying that operator to those values onto the operand stack.
</span><span class="cm"> *  
</span><span class="cm"> *  WARNING: Arithmetic expressions that ignore parentheses are not considered! And we only care about binary operator (operator with two values).
</span><span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">string</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;*</span> <span class="n">ops</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">vals</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">try</span>
    <span class="p">{</span>
        
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">input</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="p">{</span>
            <span class="c1">// Ignore the &#39;(&#39; and &#39; &#39;[space].
</span><span class="c1"></span>            <span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39; &#39;</span><span class="o">:</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="c1">// Pop the operator in &#39;ops&#39; stack and do the operator.
</span><span class="c1"></span>            <span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="o">:</span>
            <span class="p">{</span>
                <span class="kt">char</span> <span class="n">op</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">();</span>
                <span class="c1">// if (op == char())
</span><span class="c1"></span>                <span class="c1">//     throw &#34;Illegal arithmetic expression!&#34;;
</span><span class="c1"></span>                <span class="kt">int</span> <span class="n">valR</span> <span class="o">=</span> <span class="n">vals</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">();</span> 
                <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="n">valR</span> <span class="o">=</span> <span class="n">vals</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">()</span> <span class="o">+</span> <span class="n">valR</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="n">valR</span> <span class="o">=</span> <span class="n">vals</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">()</span> <span class="o">-</span> <span class="n">valR</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">)</span> <span class="n">valR</span> <span class="o">=</span> <span class="n">vals</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">()</span> <span class="o">*</span> <span class="n">valR</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">valR</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="k">throw</span> <span class="s">&#34;The divisor cannot be zero!&#34;</span><span class="p">;</span>
                    <span class="n">valR</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">()</span> <span class="o">/</span> <span class="n">valR</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">vals</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">(</span><span class="n">valR</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Arithmetic operator
</span><span class="c1"></span>            <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span>
                <span class="n">ops</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="c1">// Value 
</span><span class="c1"></span>            <span class="k">case</span> <span class="sc">&#39;0&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;1&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;2&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;3&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;4&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;5&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;6&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;7&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;8&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;9&#39;</span><span class="o">:</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
                <span class="c1">// One char of lookahead to deter whether it is a connected number or not. If the value is clear (found the end), push to the &#39;vals&#39; stack.
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">input</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">||</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="sc">&#39;9&#39;</span> <span class="o">||</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">vals</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">throw</span> <span class="s">&#34;Illegal characters in input!&#34;</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">throw</span> <span class="s">&#34;Illegal arithmetic expression!&#34;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">vals</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm"> *  A simple test:
</span><span class="cm"> *  Input the arithmetic expression(one line) and evaluate it, it will print the answer and wait for next input.
</span><span class="cm"> *  Input &#39;End&#39; to exit.
</span><span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;*</span> <span class="n">ops</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">vals</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">string</span> <span class="n">input</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">input</span> <span class="o">==</span> <span class="s">&#34;End&#34;</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Ans: &#34;</span><span class="o">&lt;&lt;</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">input</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="课程作业">课程作业<a href="#课程作业" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>这个课程作业要求我们实现两个特殊的队列形式，<code>deque</code>和<code>randomized queue</code>。[具体可以看这](<a href="https://coursera.cs.princeton.edu/algs4/assignments/queues/specification.php">Programming Assignment 2: Queues (princeton.edu)</a>)。</p>
<blockquote>
<p><strong>Dequeue.</strong> A <em>double-ended queue</em> or <em>deque</em> (pronounced “deck”) is a generalization of a stack and a queue that supports adding and removing items from either the front or the back of the data structure.</p>
</blockquote>
<p><code>Dequeue</code>实际上就是可以双头添加/删除的队列，比起<code>queue</code>队头删除队尾添加多了些选择。</p>
<blockquote>
<p><strong>Randomized queue.</strong> A <em>randomized queue</em> is similar to a stack or queue, except that the item removed is chosen uniformly at random among items in the data structure.</p>
</blockquote>
<p><code>Randomized queue</code>的话，把<code>queue</code>队头删除的特性改为了队列中随机删除。增加了随机性。</p>
<p>代码就不贴了，具体可以看Github仓库里的。</p>
<h1 id="后记">后记<a href="#后记" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<p>学习参考内容：</p>
<p><a href="https://www.coursera.org/learn/algorithms-part1">Algorithms, Part1 - Coursera</a></p>
<p><a href="https://book.douban.com/subject/19952400/">《算法 第四版》</a></p>

			</div>

<div class="related-posts thin">
	<h2></h2>
	<ul>
	
	<li><a href="/posts/union_find/">Union-Find问题的解决与方案迭代|Algorithms, Part1|第一周</a></li>
	
	</ul>
</div>

			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://ironhao-github-io.pages.dev/tags/%E7%AE%97%E6%B3%95">算法</a></span><span class="tag"><a href="https://ironhao-github-io.pages.dev/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg></p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2022-06-02 21:32 &#43;0800</p>
			</footer>
		</article>
		<aside id="toc">
			<div class="toc-title"></div>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#课程内容">课程内容</a>
      <ul>
        <li><a href="#node">Node</a></li>
        <li><a href="#bag">Bag</a></li>
        <li><a href="#stack">Stack</a></li>
        <li><a href="#queue">Queue</a></li>
        <li><a href="#应用">应用</a></li>
      </ul>
    </li>
    <li><a href="#课程作业">课程作业</a></li>
  </ul>
</nav>
		</aside>
		<div class="post-nav thin">
			<a class="prev-post" href="https://ironhao-github-io.pages.dev/posts/undefined_reference_to_in_cplusplus/">
				<span class="post-nav-label">&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>使用vscode编译C&#43;&#43;多文件(包含模板类)|解决Undefined reference to报错</span>
			</a>
		</div>
		<div id="comments" class="thin">

<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<style type="text/css">
input::input-placeholder{
	color:#e8eef2;
}
input::-webkit-input-placeholder{	
	color:#e8eef2;
}
input::-moz-placeholder{			
	color: #e8eef2;
}
input::-moz-placeholder{		
	color: #e8eef2;
}
input::-ms-input-placeholder{	
	color: #e8eef2;
}

#veditor {
	background-image: url(https://i.loli.net/2021/08/05/NhYp97G5jvCyc4t.gif);
	background-size: contain;
	background-repeat: no-repeat;
	background-position: right;
	background-color: rgb(255, 255, 255, 0);
	resize: vertical
}


.vpower.txt-right {
  display: none;
}

.v[data-class=v] .status-bar, .v[data-class=v] .veditor, .v[data-class=v] .vinput, .v[data-class=v] p, .v[data-class=v] pre code {
    color: #e8eef2;
}

.v[data-class=v] .vbtn {
    -webkit-transition-duration: .4s;
    transition-duration: .4s;
    text-align: center;
    color: #e8eef2;
    border: 1px solid #ededed;
    border-radius: .3em;
    display: inline-block;
    background: transparent;
    margin-bottom: 0;
    font-weight: 400;
    vertical-align: middle;
    -ms-touch-action: manipulation;
    touch-action: manipulation;
    cursor: pointer;
    white-space: nowrap;
    padding: .5em 1.25em;
    font-size: .875em;
    line-height: 1.42857143;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    outline: none;
}

.v[data-class=v] .vwrap .vheader .vinput {
    width: 33.33%;
    border-bottom: 1px dashed #e8eef2;
}

.v[data-class=v] .vicon {
    cursor: pointer;
    display: inline-block;
    overflow: hidden;
    fill: #e8eef2;
    vertical-align: middle;
}

.v[data-class=v] .vempty {
    padding: 1.25em;
    text-align: center;
    color: #e8eef2;
    overflow: auto;
}
</style>

<script type="text/javascript">
  new Valine({
      el: '#vcomments' ,
      appId: 'cIScCqAIMjDgsPHfDw6RKWin-gzGzoHsz',
      appKey: 'jv3B5h7m5849qtAKyOeYXCE1',
      notify: 'false', 
      verify: 'false', 
      avatar:'mm', 
      placeholder: '说点什么吧...',
      visitor: 'true'
  });
</script></div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2022 <a href="https://ironhao-github-io.pages.dev/">IronHao</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://ironhao-github-io.pages.dev/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	

	<script src="https://ironhao-github-io.pages.dev/js/bundle.min.7d8545daa55d62427355498dd8da13f98ff79a7938ce7d2a5e2ae1ec0de3beb8.js" integrity="sha256-fYVF2qVdYkJzVUmN2NoT+Y/3mnk4zn0qXirh7A3jvrg=" crossorigin="anonymous"></script>
	


   

</body>

</html>
