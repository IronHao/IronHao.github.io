<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on IronHao</title>
		<link>https://www.ironhao.top/posts/</link>
		<description>Recent content in Posts on IronHao</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-cn</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Mon, 13 Sep 2021 22:16:40 +0800</lastBuildDate>
		<atom:link href="https://www.ironhao.top/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>输入缓冲与土狼时间的实现|Unity2D学习日记（一）</title>
			<link>https://www.ironhao.top/posts/%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E4%B8%8E%E5%9C%9F%E7%8B%BC%E6%97%B6%E9%97%B4/</link>
			<pubDate>Mon, 13 Sep 2021 22:16:40 +0800</pubDate>
			
			<guid>https://www.ironhao.top/posts/%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E4%B8%8E%E5%9C%9F%E7%8B%BC%E6%97%B6%E9%97%B4/</guid>
			<description>引言 个人学习积累中，如有任何问题与错误，欢迎指出与讨论。 这系列将会记录我在搭建自己的2D平台游戏时遇到的一些问题与解决方案，核心目的均为更好</description>
			<content type="html"><![CDATA[<h2 id="引言">引言</h2>
<blockquote>
<p>个人学习积累中，如有任何问题与错误，欢迎指出与讨论。</p>
</blockquote>
<p>这系列将会记录我在搭建自己的2D平台游戏时遇到的一些问题与解决方案，核心目的均为<strong>更好的游戏体验与更棒的代码逻辑结构</strong>。<em>所有代码基于C#与Unity。</em></p>
<h2 id="正文">正文</h2>
<blockquote>
<p>跳跃的手感能衡量一个2D平台游戏的好坏。——鲁迅</p>
</blockquote>
<p>不知道你是处理玩家跳跃的判断条件的？反正就我而言，射线或者子物体检测地面图层：如果角色在地面上，则允许跳跃；反之则不允许。</p>
<p>但是这样在游玩的时候会导致一个问题：当你想要连跳时，单按跳跃键，你以为自己已经落到了地面，而实际上，你还在空中，从而造成了“<strong>按键失灵</strong>”的问题。这对于玩家的游玩体验有着相当大的影响。</p>
<p>而解决这个问题的方法，就是<strong>允许指令的预输入，在预输入后的一段时间内，若检测到条件满足，再执行操作——即“输入缓冲”。</strong></p>
<p>不过，在介绍输入缓冲的方法前，我们先来了解一下计时器。</p>
<h3 id="计时器">计时器</h3>
<p>计时器，顾名思义，是为了计算一段时间，当计时器到达设定条件后，会执行相应的操作。</p>
<p>Unity提供了一个类似的方法，<code>Invoke(&quot;方法名（无参）, 延迟时间&quot;)</code>或者<code>InvokeRepeating(&quot;方法名（无参）, 延迟时间, 间隔时间&quot;)</code>用于重复调用。但是限制较多，且不适用于我们的输入缓冲：它只能做到延迟调用，而不能在延迟的这段时间内一满足条件就调用。</p>
<p>另外还可以在协程中使用<code>yield return new WaitForSeconds(具体秒数);</code>等方法实现。同样的问题是，它也只能实现延迟调用。</p>
<p>那么，我们到底该怎么定义一个可用于输入缓冲的计时器呢？以下是个人常用的一种写法。</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="c1">// 所用变量
</span><span class="c1"></span><span class="k">private</span> <span class="kt">float</span> <span class="n">timer</span><span class="p">;</span>           <span class="c1">// 计时器
</span><span class="c1"></span><span class="k">private</span> <span class="kt">float</span> <span class="n">timer_max</span> <span class="p">=</span> <span class="m">2f</span><span class="p">;</span>       <span class="c1">// 限定时间
</span><span class="c1"></span>
<span class="c1">// 初始化，一般在按下按键时执行，实现预输入
</span><span class="c1"></span><span class="n">timer</span> <span class="p">=</span> <span class="n">timer_max</span><span class="p">;</span>

<span class="c1">// 计时过程，一般放在Update里，每帧调用
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">timer</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">timer</span> <span class="p">-=</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">timer</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">timer</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="cm">/* 计时器到点结束执行的内容，超出限定时间，类似于延迟执行的部分 */</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="cm">/* 计时器还在计算时的内容，在限定时间内，输入缓冲就可以放在这 */</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>主要思路就是利用<code>Time.deltaTime</code>来计算并减去时间，关于增量时间，<a href="https://blog.csdn.net/ChinarCSDN/article/details/82914420">这里有一篇不错的文章</a>，就不再赘述。</p>
<p>那么，接下来，利用这个计时器，实现“输入缓冲”效果吧。</p>
<h3 id="输入缓冲">输入缓冲</h3>
<p>让我们再明确下，<strong>我们想要随时能够输入跳跃指令，并让这个指令在内存中保存一定时间，在该段时间内只要满足条件（接触地面）就执行跳跃指令</strong>。以下是两种执行写法（第一种为我游戏中使用 / 第二种为在上方计时器模板上进行修改）:</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="cm">/* 所用变量 */</span>
<span class="k">private</span> <span class="kt">float</span> <span class="n">buffer_jump_counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>    	<span class="c1">// 跳跃输入缓冲计数器
</span><span class="c1"></span><span class="k">private</span> <span class="kt">float</span> <span class="n">buffer_jump_max</span> <span class="p">=</span> <span class="m">0.1f</span><span class="p">;</span>     	<span class="c1">// 跳跃输入缓冲最大值
</span><span class="c1"></span><span class="k">private</span> <span class="kt">bool</span> <span class="n">hasJumpForce</span><span class="p">;</span>            		<span class="c1">// 此时是否拥有跳跃力了，避免重复给跳跃力,该力会在接触地面后自动重置为false
</span><span class="c1"></span>
<span class="cm">/* 输入指令，Update()中 */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="n">GetButtonDown</span><span class="p">(</span><span class="s">&#34;Jump&#34;</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">buffer_jump_counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 计时器与执行指令，Update()中 */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">buffer_jump_counter</span> <span class="p">&lt;</span> <span class="n">buffer_jump_max</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">buffer_jump_counter</span> <span class="p">+=</span> <span class="p">(</span><span class="m">1</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IsOnGround</span><span class="p">()</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">hasJumpForce</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">hasJumpForce</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">AddForce</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">jumpForce</span><span class="p">),</span> <span class="n">ForceMode2D</span><span class="p">.</span><span class="n">Impulse</span><span class="p">);</span>	<span class="c1">//具体施加跳跃力操作
</span><span class="c1"></span>        <span class="n">Debug</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="s">&#34;输入缓冲，启动一次！&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>下面这种我未在游戏中测试过，不保证正确性。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="cm">/* 所用变量一致，不再赘述 */</span>

<span class="cm">/* 输入指令，Update()中 */</span>
<span class="n">buffer_jump_counter</span> <span class="p">=</span> <span class="n">buffer_jump_max</span><span class="p">;</span>

<span class="cm">/* 计时器与执行指令，Update()中 */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">buffer_jump_counter</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">buffer_jump_counter</span> <span class="p">-=</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buffer_jump_counter</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">buffer_jump_counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="cm">/* 计时器到点结束执行的内容，超出限定时间，类似于延迟执行的部分 */</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="cm">/* 计时器还在计算时的内容，在限定时间内，输入缓冲就可以放在这 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">IsOnGround</span><span class="p">()</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">hasJumpForce</span><span class="p">)</span>
    	<span class="p">{</span>
        	<span class="n">hasJumpForce</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        	<span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">AddForce</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">jumpForce</span><span class="p">),</span> <span class="n">ForceMode2D</span><span class="p">.</span><span class="n">Impulse</span><span class="p">);</span>	<span class="c1">//具体施加跳跃力操作
</span><span class="c1"></span>        	<span class="n">Debug</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="s">&#34;输入缓冲，启动一次！&#34;</span><span class="p">);</span>
    	<span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这样，我们就实现了输入缓冲的效果。输入缓冲还可以用在很多的地方，如游戏中在空中连续多次按下↓方向键实现砸击地面的效果&hellip;&hellip;更多的用法，就留待各位自行尝试了。</p>
<p>除此之外，跳跃的输入缓冲还有一个好兄弟，“土狼时间”。</p>
<h3 id="土狼时间">土狼时间</h3>
<p>土狼时间，就是让玩家所操控的人物，能够在离开平台的一段时间内，仍能执行起跳操作。它的目的，也是优化操作，减少“操作失灵”的现象。那么，我们是不是也可以用个计时器，来实现呢？可以自己先想一想。</p>
<p>怎么样，有思路了吗？</p>
<p><strong>我们只要把计时器启动的时间改为离开地面即可，当我们离开地面，又没有执行过跳跃，就可以在一定的时间内，执行跳跃指令</strong>。以下是两种执行方法（同样，第一种为我游戏中使用 / 第二种修改自计时器模板）：</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="cm">/* 所用变量 */</span>
<span class="k">private</span> <span class="kt">float</span> <span class="n">buffer_coyote_counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>    <span class="c1">// 跳跃土狼时间计数器
</span><span class="c1"></span><span class="k">private</span> <span class="kt">float</span> <span class="n">buffer_coyote_max</span> <span class="p">=</span> <span class="m">0.1f</span><span class="p">;</span>       <span class="c1">// 跳跃土狼时间最大值
</span><span class="c1"></span><span class="k">private</span> <span class="kt">bool</span> <span class="n">hasJumpForce</span><span class="p">;</span>              <span class="c1">// 此时是否拥有跳跃力了，避免重复给跳跃力
</span><span class="c1"></span>
<span class="cm">/* 初始化，在Start()中 */</span>
<span class="n">buffer_coyote_counter</span> <span class="p">=</span> <span class="n">buffer_coyote_max</span><span class="p">;</span>

<span class="cm">/* 更新指令，该函数在Update()中调用 */</span>
<span class="k">void</span> <span class="n">CheckForJump</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IsOnGround</span><span class="p">()</span> <span class="p">&amp;&amp;</span> <span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">velocity</span><span class="p">.</span><span class="n">y</span> <span class="p">&lt;</span> <span class="m">0.05f</span> <span class="p">&amp;&amp;</span> <span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">velocity</span><span class="p">.</span><span class="n">y</span> <span class="p">&gt;</span> <span class="p">-</span><span class="m">0.05f</span><span class="p">)</span>
	<span class="p">{</span>
        <span class="n">hasJumpForce</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="n">buffer_coyote_counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 计时器与执行指令，Update()中 */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">buffer_coyote_counter</span> <span class="p">&lt;</span> <span class="n">buffer_coyote_max</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">hasJumpForce</span> <span class="p">&amp;&amp;</span> <span class="n">Input</span><span class="p">.</span><span class="n">GetButtonDown</span><span class="p">(</span><span class="s">&#34;Jump&#34;</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">hasJumpForce</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">buffer_coyote_counter</span> <span class="p">=</span> <span class="n">buffer_coyote_max</span><span class="p">;</span>
        <span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">AddForce</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">jumpForce</span><span class="p">),</span> <span class="n">ForceMode2D</span><span class="p">.</span><span class="n">Impulse</span><span class="p">);</span>
        <span class="n">Debug</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="s">&#34;土狼时间，启动一次！&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">buffer_coyote_counter</span> <span class="p">&lt;</span> <span class="n">buffer_coyote_max</span><span class="p">)</span>
    <span class="n">buffer_coyote_counter</span> <span class="p">+=</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">;</span>
</code></pre></div><blockquote>
<p>下面这种我未在游戏中测试过，不保证正确性 * 2。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="cm">/* 所用变量一致，不再赘述 */</span>

<span class="cm">/* 更新指令，该函数在Update()中调用 */</span>
<span class="k">void</span> <span class="n">CheckForJump</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IsOnGround</span><span class="p">()</span> <span class="p">&amp;&amp;</span> <span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">velocity</span><span class="p">.</span><span class="n">y</span> <span class="p">&lt;</span> <span class="m">0.05f</span> <span class="p">&amp;&amp;</span> <span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">velocity</span><span class="p">.</span><span class="n">y</span> <span class="p">&gt;</span> <span class="p">-</span><span class="m">0.05f</span><span class="p">)</span>
	<span class="p">{</span>
        <span class="n">hasJumpForce</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="n">buffer_coyote_counter</span> <span class="p">=</span> <span class="n">buffer_coyote_max</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 计时器与执行指令，Update()中 */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">buffer_coyote_counter</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">buffer_coyote_counter</span> <span class="p">-=</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buffer_coyote_counter</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">buffer_coyote_counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="cm">/* 计时器到点结束执行的内容，超出限定时间，类似于延迟执行的部分 */</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="cm">/* 计时器还在计算时的内容，在限定时间内，输入缓冲就可以放在这 */</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">hasJumpForce</span> <span class="p">&amp;&amp;</span> <span class="n">Input</span><span class="p">.</span><span class="n">GetButtonDown</span><span class="p">(</span><span class="s">&#34;Jump&#34;</span><span class="p">))</span>
    	<span class="p">{</span>
        	<span class="n">hasJumpForce</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        	<span class="n">buffer_coyote_counter</span> <span class="p">=</span> <span class="n">buffer_coyote_max</span><span class="p">;</span>
        	<span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">AddForce</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">jumpForce</span><span class="p">),</span> <span class="n">ForceMode2D</span><span class="p">.</span><span class="n">Impulse</span><span class="p">);</span>
        	<span class="n">Debug</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="s">&#34;土狼时间，启动一次！&#34;</span><span class="p">);</span>
    	<span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>怎么样？这样就完美了吧。</p>
<p>其实关于游戏中的跳跃，还有很多的学问，例如<strong>如何合理高效的处理跳跃各个状态的动画（起跳、上升、最高点、下落、落地），跳跃中额外力的施加（如马里奥中的跳跃上升慢，下降快，并不只受到重力影响）&hellip;&hellip;</strong></p>
<p>其他的内容，就下次再说吧！</p>
<h2 id="后记">后记</h2>
<p>我在学习本文相关内容时，借鉴了不少帖子、视频，包括但不限于：</p>
<p><a href="https://indienova.com/indie-game-development/2d-platformer-input-buffering-design/">译文｜Gamemaker Studio系列：2D 平台游戏的输入缓冲 ——highway★</a></p>
<p><a href="https://www.bilibili.com/video/BV1fX4y1G7tv">使用Unity实现动作游戏的打击感 —— <strong>奥飒姆_Awesome</strong></a></p>
]]></content>
		</item>
		
		<item>
			<title>使用Polybrush更快更方便地搭建场景|Unity3D学习日记（二）</title>
			<link>https://www.ironhao.top/posts/unity%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%BA%8C/</link>
			<pubDate>Fri, 06 Aug 2021 22:52:37 +0800</pubDate>
			
			<guid>https://www.ironhao.top/posts/unity%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%BA%8C/</guid>
			<description>前言 本文为学习Unity途中的日常学习记录，主要是给自己的归纳总结，如有错误，还请指正。教程参考麦扣 @M_Studio的 3D RPG 核心教程。 正文 安</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本文为学习Unity途中的日常学习记录，主要是给自己的归纳总结，如有错误，还请指正。<em><strong>教程参考麦扣 @M_Studio的 3D RPG 核心教程。</strong></em></p>
<h2 id="正文">正文</h2>
<h3 id="安装polybrush">安装Polybrush</h3>
<p>同样通过点击 <code>Window -&gt; Package Manager</code> 并选择Unity Registry，找到Polybrush进行安装。注意，除了上述常规操作外，还需要单击<code>Samples</code>导入对应的Shader，如我们这使用URP，就需要导入第二个，如图所示。</p>
<p><img src="https://i.loli.net/2021/08/06/QOzM3gmZXayKnVs.png" style="zoom:67%;" /></p>
<h3 id="使用polybrush">使用Polybrush</h3>
<p>通过点击右上角的<code>Tools -&gt; Polybrush -&gt; Polybrush Window </code>来打开窗体。</p>
<p><img src="https://i.loli.net/2021/08/06/MtzAOgSBKTer4pI.png" style="zoom: 50%;" /></p>
<p>这里，<strong>从左往右</strong>的功能分别是：调整地面的高矮等状态；柔化效果；将当前的物体刷上不同的颜色；将预制体刷到场景中；将Texture刷到当前场景中。</p>
<p>另外，<code>Outer Radius</code>是外圈的大小，<code>Inner Radius</code>是内圈的大小，<code>Strength</code>是设置强度。</p>
<p><code>Brush Mirroring</code> 可以选择镜像的方向，从而刷出对称的图形。可以同时选择一个或多个轴，如我这里选择了X和Z轴。</p>
<p><img src="https://i.loli.net/2021/08/06/qkM4wpmXDNhoVA6.png" style="zoom:67%;" /></p>
<h4 id="调整地面高矮">调整地面高矮</h4>
<p>首先选中我们要进行修改的物体（这里是地面）并将Polybrush切换到第一个模式。此时地面会出现许多这样的三角形，每个点都是可以修改的。圆环是我们刷子的范围，<strong>可以通过触控板的放大缩小手势修改大小</strong>。</p>
<p><img src="https://i.loli.net/2021/08/06/e2iNcvX38sgR4Hu.png" alt=""></p>
<p><strong>鼠标点击拖拽</strong>可以向上拉升（或者双击也行，一次会升高一点）</p>
<p><img src="https://i.loli.net/2021/08/06/yj2que3cI6GC5wm.png" style="zoom:67%;" /></p>
<p><strong>按住Ctrl键</strong>会发现圆心向上的射线变成向下的了，此时再<strong>点击拖拽</strong>就可以向下挤压。</p>
<p><img src="https://i.loli.net/2021/08/06/fDLE9pnC1d2QYVi.png" alt=""></p>
<h4 id="柔化效果">柔化效果</h4>
<p><strong>选择模式二，鼠标点击拖拽即可</strong>，方法和调整地面高矮类似。个人感觉有点像模式一的撤销操作，对凸处执行会让棱角往里收，对凹处执行则会让凹陷处往回收。可以自行尝试下。</p>
<h4 id="将当前的物体刷上不同的颜色">将当前的物体刷上不同的颜色</h4>
<p><strong>选择模式三。<strong>另外，还要</strong>修改材质</strong>。找到并选中我们之前导入的文件夹中的<code>Lit Vertex Color URP </code>文件，右键<code>Create -&gt; Material</code>,Unity会为我们自动创建生成相应的材质。之后我们直接将材质拖拽到场景对应的物体（这里是地面）上去即可。</p>
<p><img src="https://i.loli.net/2021/08/06/YZpFLIlgf6M1KeB.png" style="zoom: 67%;" /></p>
<p>然后我们就可以尽情的刷颜色啦。<strong>这个的用处主要是初期场景原型搭建时用于区分各个区域，方便后续的操作。</strong></p>
<p><img src="https://i.loli.net/2021/08/06/oNYCR3AqSMrEWTP.png" style="zoom:67%;" /></p>
<p>另外，这里有三个功能选项，分别是</p>
<ul>
<li><code>Brush</code>像喷漆一样喷上颜色，同一块颜色可以越喷越深，不同颜色也可以相互影响。</li>
<li><code>Fill</code>根据三角来填充，填充上去就是最深的颜色了，会覆盖底层的颜色。</li>
<li><code>Flood</code>将整个物体刷成某个颜色</li>
</ul>
<h4 id="将预制体刷到场景中">将预制体刷到场景中</h4>
<p>选择模式四，并将需要的预制体选中并添加到<code>Current Palette</code>中。<strong>这里选中第一个，然后按住Shift并选中最后一个，就会把全部选中，此时如果有部分预制体是你不想选中的，再按住Ctrl并点击，点击的预制体就会被取消选中。</strong></p>
<p>再从调色板中将你想要刷的物体勾选上，就会显示在上方的<code>Brush Loadout</code>中，调节每个物体下方的按钮可以选择出现的概率。</p>
<p><img src="https://i.loli.net/2021/08/06/vrnFfkpqOB6txD3.png" style="zoom:50%;" /></p>
<p>然后在场景上点击就会生成啦！如果要删除，<strong>按住Ctrl再去点按生成的物体</strong>就行。由这种方法生成的树会有一圈蓝边，方便我们与其他的进行区分（同时我们也只能删除由这种方法生成的物体）。另外由于默认勾选了<code>Hit Surface is Parent</code>,所有生成的树的父类都是我们的选中的地面。</p>
<p><img src="https://i.loli.net/2021/08/06/ESgq2fGOjLDK3Vv.png" style="zoom:50%;" /></p>
<p>另外生成的时候有些物体并没有完全与地面贴合，这时候就需要我们自己手动调整了（可使用V键快速吸附！参考上一节的内容）。</p>
<h2 id="后记">后记</h2>
<p>Polybrush还是非常方便好用的，感觉要是能够结合代码，自动生成，就可以创建随机地图了。这块有空可以再研究研究！</p>
]]></content>
		</item>
		
		<item>
			<title>Unity3D导入素材与搭建场景|Unity3D学习日记（一）</title>
			<link>https://www.ironhao.top/posts/unity%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B8%80/</link>
			<pubDate>Thu, 05 Aug 2021 21:36:27 +0800</pubDate>
			
			<guid>https://www.ironhao.top/posts/unity%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B8%80/</guid>
			<description>前言 本文为学习Unity途中的日常学习记录，主要是给自己的归纳总结，如有错误，还请指正。教程参考麦扣 @M_Studio的 3D RPG 核心教程。 正文 从</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本文为学习Unity途中的日常学习记录，主要是给自己的归纳总结，如有错误，还请指正。<em><strong>教程参考麦扣 @M_Studio的 3D RPG 核心教程。</strong></em></p>
<h2 id="正文">正文</h2>
<h4 id="从商店导入所需内容">从商店导入所需内容</h4>
<p>点击左上角的 Window -&gt; Package Manager 打开对应窗体</p>
<p><img src="https://i.loli.net/2021/08/04/beJkMYX7GSH2oIa.png" alt=""></p>
<p>在新打开的窗体中的左上角，可以选择范围。</p>
<ul>
<li>一些从Unity商店中购买的素材可以在 My Assets 里找到，如果购买了而没有显示，请点击下方中间的刷新按钮，刷新一下即可</li>
<li>而如 Universal RP 等Unity提供的功能则可在 Unity Registry 里找到</li>
</ul>
<p><img src="https://i.loli.net/2021/08/04/CpOqrWzfUI73VDY.png" alt=""></p>
<p>找到对应内容后，点击右下角 Install 安装即可</p>
<h4 id="创建渲染管线">创建渲染管线</h4>
<p>右键 Assets，选择如下图的操作，点击确认，生成。</p>
<p><img src="https://i.loli.net/2021/08/04/HOPfpWGi6twNLdy.png" alt=""></p>
<p>再在右上角的 Edit -&gt; Project Setting 里找到 Graphics，设置相应的通用管线</p>
<p><img src="https://i.loli.net/2021/08/04/bNEXFxaVLHkURSf.png" alt=""></p>
<p>在Quality里的Rendering里进行同样的操作，设置通用管线</p>
<p>在导入支持URP的素材后，可以点击右上角的 Edit 按钮，执行如下操作 。其中第一个是更新全部，第二个是只更新选中的部分</p>
<p><img src="https://i.loli.net/2021/08/04/R3asLczug6vyCWm.png" alt=""></p>
<h4 id="修改通用渲染管线设置以调整阴影等">修改通用渲染管线设置以调整阴影等</h4>
<p>找到我们之前创建的通用渲染管线的Asset，单击，右边的Inspector里就会显示一些可供修改的参数。包括品质、阴影、抗锯齿等。</p>
<p>Shadows栏中，Max Distance指出最远的阴影渲染距离，超过后不再渲染，Cascade Count指出将阴影分几个层级，达到越远越虚，不同距离阴影渲染级别不同等效果。Soft Shadows勾选后阴影会变得更加柔和。</p>
<h4 id="取消显示天空盒子和替换天空盒子">取消显示天空盒子和替换天空盒子</h4>
<p>选中Scene场景，然后根据如下图所示操作取消Skybox即可。</p>
<p><img src="https://i.loli.net/2021/08/04/B5vP9a6yM3Gg4ck.png" alt=""></p>
<p>替换天空盒子的话，可以在Unity商店里找到相应的素材并导入，记得更新全部URP素材，这样素材才能正常显示。然后找到左上角的 Window 菜单，按下图所示操作，并在打开的文件夹中选择 Environment ,其中的 Skybox Matertial 就是我们可以替换的部分了</p>
<p><img src="https://i.loli.net/2021/08/04/2j6zM1yBVwxvCuN.png" alt=""></p>
<p>另外，你选择的天空盒子的Inspector中有一些参数可以修改，这里不再说明。</p>
<p>如果发现场景光颜色变得不一样，那是因为默认环境光跟随天空盒子颜色的变化而变化，我们可以在Lighting的Environment栏的Environment Lighting里进行修改。Source可以修改光来源。其中对于Skybox而言，Intensity Multiplier可以控制光受天空盒子影响的强弱。</p>
<p><img src="https://i.loli.net/2021/08/04/nzZLkig6cNS2pMA.png" alt=""></p>
<h4 id="光照设置">光照设置</h4>
<p>同样在之前设置天空盒子的Lighting里，不过是在Scene栏，我们选择 New Lighting Settings 选项，Unity会为我们自动创建。然后在Lighting的Scene栏中，选择Generate Lighting，Unity就会为我们渲染光线。<strong>注意，GPU显存较少等情况无法使用GPU进行渲染。</strong></p>
<h4 id="场景搭建小技巧">场景搭建小技巧</h4>
<ul>
<li><strong>V键为顶点自动吸附</strong>，按住V键进行方块的搭建，可以快速吸附到另一个物体（如地面）上，不需要列文虎克式微调了。具体用法，<strong>选中你想要移动的物体→按住v键，确定你要对的顶点→然后双击鼠标左键移动</strong>。</li>
<li>Prefab建议拖拽到场景栏中，而不是直接拖拽到场景中，这样会保持为（0，0，0）坐标，方便查找和后续的移动。</li>
<li>使用空的物体来作为父物体并命名，将场景中的物体拖拽到该物体上，作为它的子物体，来实现对场景中的各类物体的分类。（操作流程： 场景栏右键-&gt; Create Empty）</li>
<li>还可以使用空物体并命名，作为分隔栏使用，来区分。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>了解Big-Oh notation,以及算法的抉择</title>
			<link>https://www.ironhao.top/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%8A%89%E6%8B%A9/</link>
			<pubDate>Wed, 24 Mar 2021 19:45:07 +0800</pubDate>
			
			<guid>https://www.ironhao.top/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%8A%89%E6%8B%A9/</guid>
			<description>虽然跟着老师已经将数据结构了解了大半，但是对于O(N)的判断还是不太清楚，于是花了一个晚上的时间把书本第二章关于算法的问题又看了看，稍微写点</description>
			<content type="html"><![CDATA[<p>  虽然跟着老师已经将数据结构了解了大半，但是对于O(N)的判断还是不太清楚，于是花了一个晚上的时间把书本第二章关于算法的问题又看了看，稍微写点总结和感悟。</p>
<h2 id="big-oh-notation">Big-Oh notation</h2>
<p>  也就是我们通常所说的O(N)，它表示了一个程序的算法复杂度，一般我们说的都是时间复杂度，即需要多少时间。有以下几种常见的类型：</p>
<p><img src="https://i.loli.net/2021/03/24/LV4Cip6O3QEASsG.png" alt=""></p>
<blockquote>
<p>When we say that T(N) = O(f(N)), we are guaranteeing that the function T(N)grows at a rate no faster than f(N); thus f(N )is an upper bound on T(N).</p>
</blockquote>
<p>  就像书本说的，默认考虑的都是最坏情况，因为这才能更好的反映一个算法的好坏，保证程序在各种极端条件下的稳定性。最准确具体的O(N)算法是将加减乘除以及赋值等基础操作所花的时间当作一个单元，逐行分析计算结果，但这明显不太现实。所以我们有几个优化的小规则(个人理解版~)：</p>
<ul>
<li>对于循环，循坏几次，就是几次，比如<code>for(int i = 0; i &lt; n; i++)</code>这就是O(N)；内嵌循环也是，比如内部循环N次，外部N次，那就是O(N²)</li>
<li>忽略常数，N+6次和N+1次的区别在N趋于无穷大时可以忽略不急</li>
<li>if条件判断中，选择几个分支中O(N)最大的那个</li>
<li>如果有递归的话，从base case开始试，一步步往上累加，从中找到规律</li>
</ul>
<h2 id="算法的抉择">算法的抉择</h2>
<p>  书本后面又讲解使用了四种不同的算法去解决‘最大字串’(Maximum Subsequence Sum Problem)的问题：从暴力枚举到巧用递归再到发现利用问题的细节。时间复杂度逐步下降，但同时创造、验证算法正确性的难度也逐步提升。求快与求稳，是一个难以平衡的事情。在这个问题中，我们还可以较容易的检验每个算法（即使是最后一个）的正确与否，但是程序更复杂后就难以实现了。</p>
<p>  权衡利弊，需要靠我进一步的学习了。</p>
]]></content>
		</item>
		
		<item>
			<title>通过Single/Double Rotation来确保AVL Tree的成立|学习记录</title>
			<link>https://www.ironhao.top/posts/avl%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC/</link>
			<pubDate>Tue, 23 Mar 2021 18:33:32 +0800</pubDate>
			
			<guid>https://www.ironhao.top/posts/avl%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC/</guid>
			<description>AVL树拥有O(logN)的查找和删除速度，这也是我们创建这种数据结构的原因，但是，一次删除或者添加操作就可能破坏其脆弱的结构，因此我们需要</description>
			<content type="html"><![CDATA[<p>  AVL树拥有O(logN)的查找和删除速度，这也是我们创建这种数据结构的原因，但是，一次删除或者添加操作就可能破坏其脆弱的结构，因此我们需要Single/Double Rotation来保证其结构的正确。</p>
<h2 id="什么是avl树">什么是AVL树</h2>
<blockquote>
<p>AVL tree is binary search tree with self balancing ability.</p>
<p>Its height difference between the right and left subtree of all nodes not greater than one.</p>
</blockquote>
<p>  简单来说，就是一个每个叶子的高度差不大于一的二叉搜索树。</p>
<h2 id="sd-rotation">S/D Rotation</h2>
<h4 id="为什么需要">为什么需要</h4>
<p><img src="https://i.loli.net/2021/03/23/UIB7ct5MvCQbRd3.png" alt=""></p>
<p>  如图所示，一次简单的插入操作后，200右边的高度变成了4，而左边为2，叶子的高度差大于1，直接破坏了AVL树的结构。通过Single/Double Rotation，我们可以恢复其结构。</p>
<h4 id="使用时机与选择">使用时机与选择</h4>
<blockquote>
<p>这边有一个平衡系数用来判断其高度差。</p>
<p>即 左子树的高度 - 右子树的高度 = 该节点的平衡系数</p>
</blockquote>
<p>  简单来说，就是找，找到某个节点，其左右子树高度差大于二，那么此时就需要旋转了。一般来说，会有这么四种情况：</p>
<ul>
<li>左边子树的左节点过长（Left – Left Rotation）</li>
<li>右边子树的右节点过长（Right – Right Rotation）</li>
<li>右边子树的左节点过长（Right – Left Rotation）</li>
<li>左边子树的右节点过长（Left – Right Rotation)</li>
</ul>
<p>  前两种情况使用Single Rotation即可解决，后两种情况较为复杂，需要使用Double Rotation来解决。</p>
<h4 id="single-rotation">Single Rotation</h4>
<p>  上图就是一个R-R Rotation，即右子树的右节点过长。正常来说，我们需要按照以下步骤：</p>
<p><img src="https://i.loli.net/2021/03/23/WPJlkpsrtBzEdvM.jpg" alt=""></p>
<ol>
<li>找到不平衡的点，即其平衡系数绝对值大于1(注意，这个点可能有好多个，应该选择层数最高的那个)</li>
<li>如图标红的线就是我们要移动的，我们将200绕着400逆时针旋转，把350挤掉（350与400的连线断开），使200成为400的左节点</li>
<li>将350作为200的右节点连接起来</li>
<li>完成</li>
</ol>
<p>  一个印象可能不够深刻，下图可以当一个练习。</p>
<p><img src="https://i.loli.net/2021/03/23/CJnaNqoWK9fD23i.png" alt=""></p>
<h4 id="double-rotation">Double Rotation</h4>
<p>  我们可以简单粗暴的理解成两次Single Rotation，以下是我们的操作流程:</p>
<p><img src="https://i.loli.net/2021/03/23/l5XAFpmSI4nMRdr.png" alt=""></p>
<ol>
<li>
<p>同样的，找到不平衡的点，这里4，6都是，我们应该选择6</p>
</li>
<li>
<p>两条虚线就是我们要移动的线，我们首先移动下面一条(即7和15连着的线)，我们将15绕着7顺时针旋转，挤掉14，再将14拼接在15上，结果如图所示(仅展示移动部分)</p>
<p><img src="https://i.loli.net/2021/03/23/Osy4dgIDmoBEpPH.png" alt=""></p>
</li>
<li>
<p>同样的操作，移动6和15连着的线，将6绕着7逆时针旋转(这时候没有需要挤掉的数)，将其变为7的左节点，结束</p>
</li>
</ol>
<h2 id="小结">小结</h2>
<p>  这块内容上课时没听清楚，花了挺久的时间才整明白，感觉网上的资料写的不是特别详细，只有开始与结果图，没有过程讲解，所以我就来写一写，既强化下记忆，也能帮助有需要的人~</p>
<p><em>网上参考资料:</em> <a href="https://www.guru99.com/avl-tree.html">https://www.guru99.com/avl-tree.html</a></p>
]]></content>
		</item>
		
		<item>
			<title>构造D-Heap并理解其插入删除算法|学习记录</title>
			<link>https://www.ironhao.top/posts/d-heap/</link>
			<pubDate>Fri, 19 Mar 2021 17:14:50 +0800</pubDate>
			
			<guid>https://www.ironhao.top/posts/d-heap/</guid>
			<description>这几周在痛苦的学习数据结构，老师给我们布置了一个构造D-Heap的作业，断断续续debug了两天，总算是实现了。这里就记录一下我的思路与过程</description>
			<content type="html"><![CDATA[<p>  这几周在痛苦的学习数据结构，老师给我们布置了一个构造D-Heap的作业，断断续续debug了两天，总算是实现了。这里就记录一下我的思路与过程。</p>
<h2 id="什么是d-heap">什么是D-Heap？</h2>
<blockquote>
<p>以下为个人目前见解，还在学习中，不一定完全正确。</p>
</blockquote>
<p>  首先，它是一个堆（heap）结构，我们常说的堆结构Binary-heap（这里以最小堆为例）应该满足以下两点：</p>
<ul>
<li>是一个完全二叉树（这样才能够存储在数组里）</li>
<li>每个父节点都要小于其子节点（最大堆相反）</li>
</ul>
<p>  而D-Heap可以理解为其变式，或者称为泛型，它的每个父节点可以拥有D个子节点。</p>
<h2 id="构造d-heap">构造D-Heap</h2>
<p>  Heap是存放在数组中的，通过简单的画格子方法，我们可以找到一个规律（假设我们从下标为0开始存数），<strong>第i位的数恰巧为第i * d 到第（i+1) * d位数的父节点</strong>，这也是我们构造的关键。</p>
<h4 id="插入">插入</h4>
<p>  插入的思路如下：</p>
<ol>
<li>将插入的数据存放在队尾；</li>
<li>由队尾的叶子开始，与其父节点进行比较，若父大子小，则进行交换，即选较小值作为父节点（默认为最大堆）;</li>
<li>重复第2步骤，直至不再需要交换或者遍历到了根节点，表明堆已是有序的了。</li>
</ol>
<p>  而由子节点找父节点的方法就用到了我们上面的规律，第（i-1）/d位的节点即使第i位的父节点。</p>
<p><img src="https://i.loli.net/2021/03/19/hcCtAOoue1RUiND.png" alt=""><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<h4 id="删除">删除</h4>
<p>  与插入的思路恰好相反，由根节点开始操作：</p>
<ol>
<li>保存好第0位的数据（如果你要返回被删除的值话），将最后一位的数据存放至第0位，覆盖掉，再删除掉最后一位；</li>
<li>从根节点开始，找到其子节点（总共有d个）中的最小值，如果父大子小，则交换他们；</li>
<li>重复第2步骤，直到交换完最后一层或不再交换。</li>
</ol>
<p><img src="https://i.loli.net/2021/03/19/YwinmT2BAuXhN7F.png" alt=""><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<h4 id="具体代码实现">具体代码实现</h4>
<p>  这边d我设置为4（按照题目要求)，可以修改为一个变量d，在初始化的时候确定。同时为了便于代码的阅读，我将交换（swap）和查找子节点最小数（minInOneSubTree）整合为私有方法。另外又设置了min这个结构，里面存有最小值的大小，对应的下标，以及是否存在（exist，主要用来解决只有1个的极端条件）。代码本身肯定还不够精简，还不是最终版本，可以作为参考。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">quadHeap</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">quadHeap</span><span class="p">()</span>
        <span class="p">{</span>
             <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CAPACITY</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
             <span class="p">{</span>
                 <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
             <span class="p">}</span>
        <span class="p">}</span>

        <span class="o">~</span><span class="n">quadHeap</span><span class="p">()</span>
        <span class="p">{</span>

        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">T</span> <span class="n">element</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">data</span><span class="p">[</span><span class="n">currentSize</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">currentIndex</span> <span class="o">=</span> <span class="n">currentSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">notOrdered</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">notOrdered</span> <span class="o">&amp;&amp;</span> <span class="n">currentIndex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">notOrdered</span> <span class="o">=</span> <span class="n">swap</span><span class="p">(</span><span class="n">currentIndex</span><span class="p">);</span>
                <span class="n">currentIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">currentIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
            <span class="p">}</span> 
        <span class="p">}</span>
            

        <span class="n">T</span> <span class="nf">deleteMin</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">T</span> <span class="n">returnElement</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">T</span> <span class="n">lastElement</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">--</span><span class="n">currentSize</span><span class="p">];</span>
            <span class="n">data</span><span class="p">[</span><span class="n">currentSize</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">returnElement</span><span class="p">;</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastElement</span><span class="p">;</span>
            <span class="n">min</span> <span class="n">minOne</span><span class="p">;</span>
            <span class="n">minOne</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">minOne</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">minOne</span><span class="p">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">currentSize</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">minOne</span> <span class="o">=</span> <span class="n">minInOneSubTree</span><span class="p">(</span><span class="n">minOne</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">minOne</span><span class="p">.</span><span class="n">exist</span><span class="p">)</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">minOne</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">returnElement</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">print</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">currentSize</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="k">struct</span> <span class="nc">min</span>
        <span class="p">{</span>
            <span class="n">T</span> <span class="n">data</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">exist</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 
        <span class="p">};</span>
        
        <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">CAPACITY</span> <span class="o">=</span> <span class="mi">61</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">currentSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">data</span><span class="p">[</span><span class="n">CAPACITY</span><span class="p">];</span>

        <span class="kt">bool</span> <span class="nf">swap</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            

            <span class="kt">bool</span> <span class="n">isChanged</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">preIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
            <span class="n">T</span> <span class="n">temp</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">preIndex</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">isChanged</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">preIndex</span><span class="p">];</span>
                <span class="n">data</span><span class="p">[</span><span class="n">preIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
                <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">isChanged</span><span class="p">;</span>
        <span class="p">}</span>


        <span class="n">min</span> <span class="nf">minInOneSubTree</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">min</span> <span class="n">minOne</span><span class="p">;</span>
            <span class="n">minOne</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
            <span class="n">minOne</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">minOne</span><span class="p">.</span><span class="n">data</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">minOne</span><span class="p">.</span><span class="n">exist</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">minOne</span><span class="p">;</span>
            <span class="p">}</span>
           
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">minOne</span><span class="p">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="p">{</span>
                    <span class="n">minOne</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">minOne</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">minOne</span><span class="p">;</span>
        <span class="p">}</span>

<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">quadHeap</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">testHeap</span><span class="p">;</span>
   
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Test&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">testHeap</span><span class="p">.</span><span class="n">deleteMin</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">testHeap</span><span class="p">.</span><span class="n">deleteMin</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">testHeap</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">testHeap</span><span class="p">.</span><span class="n">deleteMin</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">testHeap</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><h2 id="小结">小结</h2>
<p>  写出来没错就好，也算进步了一点~</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>图片来自Mark A. Weiss - Data Structures and Algorithm Analysis in C++-Pearson (2014) <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>图片来自Mark A. Weiss - Data Structures and Algorithm Analysis in C++-Pearson (2014) <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
		</item>
		
		<item>
			<title>约瑟夫环的两种设计——结构化设计与OOP | 学习记录</title>
			<link>https://www.ironhao.top/posts/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1/</link>
			<pubDate>Sun, 14 Mar 2021 20:42:34 +0800</pubDate>
			
			<guid>https://www.ironhao.top/posts/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1/</guid>
			<description>周末赶了一个关于程序设计的作业，题目让我们分别用结构化设计与基于面向对象的设计思路来完成约瑟夫环的问题，刚好顺便复习下链表，以下是一点过程记</description>
			<content type="html"><![CDATA[<p>  周末赶了一个关于程序设计的作业，题目让我们分别用结构化设计与基于面向对象的设计思路来完成约瑟夫环的问题，刚好顺便复习下链表，以下是一点过程记录。</p>
<h2 id="约瑟夫环的实现">约瑟夫环的实现</h2>
<h4 id="结构化设计">结构化设计</h4>
<p>  这一块网络上的资料也很多，我这里提供一种方法。总的思路就是使用累加器来记录报数，到指定人数后将对应的人“杀死”，一直循环直至剩下一人，返回存活人的号码。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">nrOfPeople</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>   <span class="c1">// 总人数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">nrOfDead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// 死亡人数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">M</span><span class="p">;</span>  <span class="c1">// 题目所指定的M，报数报到M即死亡
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 第index个人
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 当前报数
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">survival</span><span class="p">[</span><span class="n">nrOfPeople</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>  <span class="c1">// 记录第n个人是否死亡
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Input M &#34;</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">M</span><span class="p">;</span>

    <span class="c1">// 初始化，全部人一开始都活着
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nrOfPeople</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">survival</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 开始筛选
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Dead: &#34;</span><span class="p">;</span>
    <span class="k">do</span>
    <span class="p">{</span>
        <span class="n">index</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">nrOfPeople</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">survival</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">number</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="o">==</span> <span class="n">M</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
            <span class="n">survival</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="n">nrOfDead</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">nrOfDead</span> <span class="o">!=</span> <span class="n">nrOfPeople</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 筛选至只剩一人结束
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 输出幸存的人所处位置
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Left one: &#34;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="n">nrOfPeople</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">survival</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h4 id="基于面向对象oop">基于面向对象（OOP）</h4>
<p>  根据我目前对OOP的理解，就是将问题分为许多个小问题，再将其封装成类，一个类解决一个问题。在这个约瑟夫环问题中，我分了三类：</p>
<ul>
<li>整个约瑟夫环的过程（JosephusProblem）</li>
<li>约瑟夫环中的人（PeopleInJos）</li>
<li>报数器（Number)</li>
</ul>
<p>  和结构化设计解决约瑟夫环的思路类似，将不同的内容分类塞入这三类里。JosephusProblem中，我们要控制游戏的过程，所以相应的初始化，以及需要的变量，包括调用其他两个类的两个变量，总人数、死亡人数，以及一个指向队首的指针（因为我使用了循环链表来存储人）。PeopleInJos中，存放每个人所必须的信息，在这里只有两个，存活与否（isSurvival)和他对应的号码（index），当然，因为类要封装，都必须设置相应的方法来调用到这些私有变量。Number中很简单，就是累加，到点了就返回相应的提示并重置，这个我集成在同一个方法（bool out()）里了。以下是具体代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// JosephusProblemOOP.cpp:
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;JosephusProblem.cpp&#34;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>   
    <span class="n">JosephusProblem</span> <span class="n">j</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">41</span><span class="p">);</span>
    <span class="n">j</span><span class="p">.</span><span class="n">initializa</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">.</span><span class="n">start</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// JosephusProblem.cpp:
</span><span class="c1"></span><span class="cp">#pragma once
</span><span class="cp">#include</span> <span class="cpf">&#34;PeopleInJos.cpp&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;Number.cpp&#34;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">JosephusProblem</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">JosephusProblem</span><span class="p">()</span>
        <span class="p">{</span>

        <span class="p">}</span>

        <span class="n">JosephusProblem</span><span class="p">(</span><span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PeopleInJos</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">num</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Number</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">nrOfPeople</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">nrOfDead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">initializa</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">PeopleInJos</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nrOfPeople</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">temp</span><span class="o">-&gt;</span><span class="n">setNext</span><span class="p">(</span><span class="k">new</span> <span class="n">PeopleInJos</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">temp</span><span class="o">-&gt;</span><span class="n">setNext</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="nf">start</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">tempI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">currentP</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="k">do</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">currentP</span><span class="o">-&gt;</span><span class="n">survival</span><span class="p">())</span>
                <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">num</span><span class="o">-&gt;</span><span class="n">out</span><span class="p">())</span>
                    <span class="p">{</span>
                        <span class="n">currentP</span><span class="o">-&gt;</span><span class="n">kill</span><span class="p">();</span>
                        <span class="n">nrOfDead</span><span class="o">++</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">currentP</span> <span class="o">=</span> <span class="n">currentP</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">nrOfDead</span> <span class="o">!=</span> <span class="n">nrOfPeople</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            
            <span class="n">currentP</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nrOfPeople</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">currentP</span><span class="o">-&gt;</span><span class="n">survival</span><span class="p">())</span>
                <span class="p">{</span>
                    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">currentP</span> <span class="o">=</span> <span class="n">currentP</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span> 
        <span class="n">Number</span><span class="o">*</span> <span class="n">num</span><span class="p">;</span>
        <span class="n">PeopleInJos</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">PeopleInJos</span><span class="o">*</span> <span class="n">currentP</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nrOfPeople</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nrOfDead</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Number.cpp:
</span><span class="c1"></span><span class="cp">#pragma once
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Number</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Number</span><span class="p">()</span>
        <span class="p">{</span>

        <span class="p">}</span>
        
        <span class="n">Number</span><span class="p">(</span><span class="kt">int</span> <span class="n">M</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">currentN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">setM</span> <span class="o">=</span> <span class="n">M</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="nf">out</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">currentN</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">currentN</span> <span class="o">&gt;=</span> <span class="n">setM</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">currentN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">currentN</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">setM</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// PeopleInJos.cpp:
</span><span class="c1"></span><span class="cp"># pragma once
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">PeopleInJos</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">PeopleInJos</span><span class="p">()</span>
        <span class="p">{</span>

        <span class="p">}</span>

        <span class="n">PeopleInJos</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">isSurvival</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">PeopleInJos</span><span class="o">*</span> <span class="nf">getNext</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">setNext</span><span class="p">(</span><span class="n">PeopleInJos</span><span class="o">*</span> <span class="n">next</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="nf">survival</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">isSurvival</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">kill</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">isSurvival</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">PeopleInJos</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">isSurvival</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
<span class="p">};</span>

</code></pre></div><h2 id="一些想法">一些想法</h2>
<p>  毕竟是开学初，刚开始系统的学习OOP设计思路，也许上面的类划分不够细致，不过程序跑起来后，感觉还是不错的，代码个人看着也还是比较清晰的。当然基于OOP设计的程序还是有点问题的，使用了指针却没有手动内存释放，会导致内存泄漏等。这些就留待下次有空完成吧~</p>
]]></content>
		</item>
		
		<item>
			<title>完善博客的第一步</title>
			<link>https://www.ironhao.top/posts/%E5%AE%8C%E5%96%84%E5%8D%9A%E5%AE%A2/</link>
			<pubDate>Sat, 13 Mar 2021 15:55:59 +0800</pubDate>
			
			<guid>https://www.ironhao.top/posts/%E5%AE%8C%E5%96%84%E5%8D%9A%E5%AE%A2/</guid>
			<description>​ 趁着周末，把之前刚刚搭建好的博客完善下~大部分的内容主题已经满足了，剩下的就是部署到github page上了。 目标 部署到github pag</description>
			<content type="html"><![CDATA[<p>​		趁着周末，把之前刚刚搭建好的博客完善下~大部分的内容主题已经满足了，剩下的就是部署到github page上了。</p>
<h2 id="目标">目标</h2>
<ul>
<li>部署到github page上，实现对外开放</li>
<li>绑定域名</li>
<li>使用PicGo来实现快速上传图片至图床</li>
</ul>
<h2 id="过程">过程</h2>
<h4 id="部署">部署</h4>
<p>​		部署还是比较方便的，网上有很多教程，这里我讲讲我的方法：</p>
<ol>
<li>
<p>在github上创建一个新的仓库，命名为yourname.github.io；</p>
</li>
<li>
<p>鉴于github推出了自己的桌面程序（GitHub Desktop），我们可以直接使用这个程序来绑定仓库。在网页新创一个仓库后，github会提示你如</p>
<p>下图所示内容，我们选择“Set up in Desktop&quot;,就可以打开程序，然后选择路径为你的博客需要上传的部分。（如我用的hugo，就设置路径为&hellip;/public）</p>
<p>PS: 绑定时本地文件夹里必须为空</p>
<p><img src="https://i.loli.net/2021/03/13/pPiUaoxF7eZcfRq.png" alt=""></p>
</li>
<li>
<p>完成，一切正常的话，接下来你就可以输入网址 <a href="http://yourname.github.io/">http://yourname.github.io/</a> 访问你的博客了</p>
</li>
</ol>
<h4 id="绑定域名">绑定域名</h4>
<p>​		在仓库的setting里，找到关于Github Page的设置，如下图所示</p>
<p><img src="https://i.loli.net/2021/03/13/XqZUMOgKGtdy2ks.png" alt=""></p>
<p>​		在Custom domain里，输入你的域名，顺便开启强制HTTPS。</p>
<p>​		另一方面，在cmd里输入 ping yourname.github.io，找到对应的ip，在域名那边添加两条解析，如下图所示，一条CNAME指向github分给你的域名，另一条A指向对应的ip。</p>
<p><img src="https://i.loli.net/2021/03/13/YPibhprVyURIMc8.png" alt=""></p>
<p>​		到这里，域名绑定算是完成了。但是打开网页，发现证书无效，显示网页为“不安全”状态。这怎么能忍，于是我决定配置Cloudflare来使用HTTPS，具体流程官网会提供的，<a href="https://dash.cloudflare.com/sign-up">点我转至Cloudflare官网</a>。</p>
<p>​		其中最后需要修改下DNS服务器，像万网点击“管理” → “DNS修改”就能找到了。</p>
<h4 id="picgo绑定">PicGo绑定</h4>
<p>​		PicGo在Github上搜索后就可以找到对应的项目仓库，进行下载。</p>
<p>​		我使用的图床是SM.MS，注册后点击右上角“User”→“Dashboard”→“API Token”→“Generate Secret Token”生成需要的密钥，然后复制到picgo对应的位置即可。</p>
<h2 id="结尾">结尾</h2>
<p>​		过程有些曲折，不过解决了就好~</p>
<p>​		参考文章：https://zhuanlan.zhihu.com/p/37752930</p>
]]></content>
		</item>
		
		<item>
			<title>反反复复的日常</title>
			<link>https://www.ironhao.top/posts/firstday/</link>
			<pubDate>Fri, 12 Mar 2021 20:09:01 +0800</pubDate>
			
			<guid>https://www.ironhao.top/posts/firstday/</guid>
			<description>​ 认认真真的静下心来学习。 ​ 反反复复的玩了不少博客框架，每次都是三分钟热度，搭完之后就闲置在那了。上一个用typecho的博客，搭了快一年，</description>
			<content type="html"><![CDATA[<p>​	认认真真的静下心来学习。</p>
<p>​	反反复复的玩了不少博客框架，每次都是三分钟热度，搭完之后就闲置在那了。上一个用typecho的博客，搭了快一年，服务器都要到期了，也没写几篇文章，有点失败。这次打算转github-page来部署博客，不用花多余的钱去买服务器，也不用担心博客消失、转移等一系列麻烦的事情。</p>
<p>​	在这里稍稍的写一下自己博客的用处吧：</p>
<ul>
<li>
<p>作为一名软工大二的学生，用博客记录下自己平时学习所得，顺带巩固</p>
</li>
<li>
<p>平日里看了不少电影，在博客里写一些观后感</p>
</li>
<li>
<p>记录生活</p>
<p><img src="https://i.loli.net/2021/03/12/a5jBz9Gmt32QdHp.jpg" alt="VXqlb7r1_橙色云插画.jpg"></p>
</li>
</ul>
]]></content>
		</item>
		
	</channel>
</rss>
