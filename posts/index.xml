<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on IronHao</title>
		<link>https://www.ironhao.top/posts/</link>
		<description>Recent content in Posts on IronHao</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-cn</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Wed, 24 Mar 2021 19:45:07 +0800</lastBuildDate>
		<atom:link href="https://www.ironhao.top/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>了解Big-Oh notation,以及算法的抉择</title>
			<link>https://www.ironhao.top/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%8A%89%E6%8B%A9/</link>
			<pubDate>Wed, 24 Mar 2021 19:45:07 +0800</pubDate>
			
			<guid>https://www.ironhao.top/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%8A%89%E6%8B%A9/</guid>
			<description>虽然跟着老师已经将数据结构了解了大半，但是对于O(N)的判断还是不太清楚，于是花了一个晚上的时间把书本第二章关于算法的问题又看了看，稍微写点</description>
			<content type="html"><![CDATA[<p>  虽然跟着老师已经将数据结构了解了大半，但是对于O(N)的判断还是不太清楚，于是花了一个晚上的时间把书本第二章关于算法的问题又看了看，稍微写点总结和感悟。</p>
<h2 id="big-oh-notation">Big-Oh notation</h2>
<p>  也就是我们通常所说的O(N)，它表示了一个程序的算法复杂度，一般我们说的都是时间复杂度，即需要多少时间。有以下几种常见的类型：</p>
<p><img src="https://i.loli.net/2021/03/24/LV4Cip6O3QEASsG.png" alt=""></p>
<blockquote>
<p>When we say that T(N) = O(f(N)), we are guaranteeing that the function T(N)grows at a rate no faster than f(N); thus f(N )is an upper bound on T(N).</p>
</blockquote>
<p>  就像书本说的，默认考虑的都是最坏情况，因为这才能更好的反映一个算法的好坏，保证程序在各种极端条件下的稳定性。最准确具体的O(N)算法是将加减乘除以及赋值等基础操作所花的时间当作一个单元，逐行分析计算结果，但这明显不太现实。所以我们有几个优化的小规则(个人理解版~)：</p>
<ul>
<li>对于循环，循坏几次，就是几次，比如<code>for(int i = 0; i &lt; n; i++)</code>这就是O(N)；内嵌循环也是，比如内部循环N次，外部N次，那就是O(N²)</li>
<li>忽略常数，N+6次和N+1次的区别在N趋于无穷大时可以忽略不急</li>
<li>if条件判断中，选择几个分支中O(N)最大的那个</li>
<li>如果有递归的话，从base case开始试，一步步往上累加，从中找到规律</li>
</ul>
<h2 id="算法的抉择">算法的抉择</h2>
<p>  书本后面又讲解使用了四种不同的算法去解决‘最大字串’(Maximum Subsequence Sum Problem)的问题：从暴力枚举到巧用递归再到发现利用问题的细节。时间复杂度逐步下降，但同时创造、验证算法正确性的难度也逐步提升。求快与求稳，是一个难以平衡的事情。在这个问题中，我们还可以较容易的检验每个算法（即使是最后一个）的正确与否，但是程序更复杂后就难以实现了。</p>
<p>  权衡利弊，需要靠我进一步的学习了。</p>
]]></content>
		</item>
		
		<item>
			<title>通过Single/Double Rotation来确保AVL Tree的成立|学习记录</title>
			<link>https://www.ironhao.top/posts/avl%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC/</link>
			<pubDate>Tue, 23 Mar 2021 18:33:32 +0800</pubDate>
			
			<guid>https://www.ironhao.top/posts/avl%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC/</guid>
			<description>AVL树拥有O(logN)的查找和删除速度，这也是我们创建这种数据结构的原因，但是，一次删除或者添加操作就可能破坏其脆弱的结构，因此我们需要</description>
			<content type="html"><![CDATA[<p>  AVL树拥有O(logN)的查找和删除速度，这也是我们创建这种数据结构的原因，但是，一次删除或者添加操作就可能破坏其脆弱的结构，因此我们需要Single/Double Rotation来保证其结构的正确。</p>
<h2 id="什么是avl树">什么是AVL树</h2>
<blockquote>
<p>AVL tree is binary search tree with self balancing ability.</p>
<p>Its height difference between the right and left subtree of all nodes not greater than one.</p>
</blockquote>
<p>  简单来说，就是一个每个叶子的高度差不大于一的二叉搜索树。</p>
<h2 id="sd-rotation">S/D Rotation</h2>
<h4 id="为什么需要">为什么需要</h4>
<p><img src="https://i.loli.net/2021/03/23/UIB7ct5MvCQbRd3.png" alt=""></p>
<p>  如图所示，一次简单的插入操作后，200右边的高度变成了4，而左边为2，叶子的高度差大于1，直接破坏了AVL树的结构。通过Single/Double Rotation，我们可以恢复其结构。</p>
<h4 id="使用时机与选择">使用时机与选择</h4>
<blockquote>
<p>这边有一个平衡系数用来判断其高度差。</p>
<p>即 左子树的高度 - 右子树的高度 = 该节点的平衡系数</p>
</blockquote>
<p>  简单来说，就是找，找到某个节点，其左右子树高度差大于二，那么此时就需要旋转了。一般来说，会有这么四种情况：</p>
<ul>
<li>左边子树的左节点过长（Left – Left Rotation）</li>
<li>右边子树的右节点过长（Right – Right Rotation）</li>
<li>右边子树的左节点过长（Right – Left Rotation）</li>
<li>左边子树的右节点过长（Left – Right Rotation)</li>
</ul>
<p>  前两种情况使用Single Rotation即可解决，后两种情况较为复杂，需要使用Double Rotation来解决。</p>
<h4 id="single-rotation">Single Rotation</h4>
<p>  上图就是一个R-R Rotation，即右子树的右节点过长。正常来说，我们需要按照以下步骤：</p>
<p><img src="https://i.loli.net/2021/03/23/WPJlkpsrtBzEdvM.jpg" alt=""></p>
<ol>
<li>找到不平衡的点，即其平衡系数绝对值大于1(注意，这个点可能有好多个，应该选择层数最高的那个)</li>
<li>如图标红的线就是我们要移动的，我们将200绕着400逆时针旋转，把350挤掉（350与400的连线断开），使200成为400的左节点</li>
<li>将350作为200的右节点连接起来</li>
<li>完成</li>
</ol>
<p>  一个印象可能不够深刻，下图可以当一个练习。</p>
<p><img src="https://i.loli.net/2021/03/23/CJnaNqoWK9fD23i.png" alt=""></p>
<h4 id="double-rotation">Double Rotation</h4>
<p>  我们可以简单粗暴的理解成两次Single Rotation，以下是我们的操作流程:</p>
<p><img src="https://i.loli.net/2021/03/23/l5XAFpmSI4nMRdr.png" alt=""></p>
<ol>
<li>
<p>同样的，找到不平衡的点，这里4，6都是，我们应该选择6</p>
</li>
<li>
<p>两条虚线就是我们要移动的线，我们首先移动下面一条(即7和15连着的线)，我们将15绕着7顺时针旋转，挤掉14，再将14拼接在15上，结果如图所示(仅展示移动部分)</p>
<p><img src="https://i.loli.net/2021/03/23/Osy4dgIDmoBEpPH.png" alt=""></p>
</li>
<li>
<p>同样的操作，移动6和15连着的线，将6绕着7逆时针旋转(这时候没有需要挤掉的数)，将其变为7的左节点，结束</p>
</li>
</ol>
<h2 id="小结">小结</h2>
<p>  这块内容上课时没听清楚，花了挺久的时间才整明白，感觉网上的资料写的不是特别详细，只有开始与结果图，没有过程讲解，所以我就来写一写，既强化下记忆，也能帮助有需要的人~</p>
<p><em>网上参考资料:</em> <a href="https://www.guru99.com/avl-tree.html">https://www.guru99.com/avl-tree.html</a></p>
]]></content>
		</item>
		
		<item>
			<title>构造D-Heap并理解其插入删除算法|学习记录</title>
			<link>https://www.ironhao.top/posts/d-heap/</link>
			<pubDate>Fri, 19 Mar 2021 17:14:50 +0800</pubDate>
			
			<guid>https://www.ironhao.top/posts/d-heap/</guid>
			<description>这几周在痛苦的学习数据结构，老师给我们布置了一个构造D-Heap的作业，断断续续debug了两天，总算是实现了。这里就记录一下我的思路与过程</description>
			<content type="html"><![CDATA[<p>  这几周在痛苦的学习数据结构，老师给我们布置了一个构造D-Heap的作业，断断续续debug了两天，总算是实现了。这里就记录一下我的思路与过程。</p>
<h2 id="什么是d-heap">什么是D-Heap？</h2>
<blockquote>
<p>以下为个人目前见解，还在学习中，不一定完全正确。</p>
</blockquote>
<p>  首先，它是一个堆（heap）结构，我们常说的堆结构Binary-heap（这里以最小堆为例）应该满足以下两点：</p>
<ul>
<li>是一个完全二叉树（这样才能够存储在数组里）</li>
<li>每个父节点都要小于其子节点（最大堆相反）</li>
</ul>
<p>  而D-Heap可以理解为其变式，或者称为泛型，它的每个父节点可以拥有D个子节点。</p>
<h2 id="构造d-heap">构造D-Heap</h2>
<p>  Heap是存放在数组中的，通过简单的画格子方法，我们可以找到一个规律（假设我们从下标为0开始存数），<strong>第i位的数恰巧为第i * d 到第（i+1) * d位数的父节点</strong>，这也是我们构造的关键。</p>
<h4 id="插入">插入</h4>
<p>  插入的思路如下：</p>
<ol>
<li>将插入的数据存放在队尾；</li>
<li>由队尾的叶子开始，与其父节点进行比较，若父大子小，则进行交换，即选较小值作为父节点（默认为最大堆）;</li>
<li>重复第2步骤，直至不再需要交换或者遍历到了根节点，表明堆已是有序的了。</li>
</ol>
<p>  而由子节点找父节点的方法就用到了我们上面的规律，第（i-1）/d位的节点即使第i位的父节点。</p>
<p><img src="https://i.loli.net/2021/03/19/hcCtAOoue1RUiND.png" alt=""><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<h4 id="删除">删除</h4>
<p>  与插入的思路恰好相反，由根节点开始操作：</p>
<ol>
<li>保存好第0位的数据（如果你要返回被删除的值话），将最后一位的数据存放至第0位，覆盖掉，再删除掉最后一位；</li>
<li>从根节点开始，找到其子节点（总共有d个）中的最小值，如果父大子小，则交换他们；</li>
<li>重复第2步骤，直到交换完最后一层或不再交换。</li>
</ol>
<p><img src="https://i.loli.net/2021/03/19/YwinmT2BAuXhN7F.png" alt=""><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<h4 id="具体代码实现">具体代码实现</h4>
<p>  这边d我设置为4（按照题目要求)，可以修改为一个变量d，在初始化的时候确定。同时为了便于代码的阅读，我将交换（swap）和查找子节点最小数（minInOneSubTree）整合为私有方法。另外又设置了min这个结构，里面存有最小值的大小，对应的下标，以及是否存在（exist，主要用来解决只有1个的极端条件）。代码本身肯定还不够精简，还不是最终版本，可以作为参考。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">quadHeap</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">quadHeap</span><span class="p">()</span>
        <span class="p">{</span>
             <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CAPACITY</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
             <span class="p">{</span>
                 <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
             <span class="p">}</span>
        <span class="p">}</span>

        <span class="o">~</span><span class="n">quadHeap</span><span class="p">()</span>
        <span class="p">{</span>

        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">T</span> <span class="n">element</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">data</span><span class="p">[</span><span class="n">currentSize</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">currentIndex</span> <span class="o">=</span> <span class="n">currentSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">notOrdered</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">notOrdered</span> <span class="o">&amp;&amp;</span> <span class="n">currentIndex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">notOrdered</span> <span class="o">=</span> <span class="n">swap</span><span class="p">(</span><span class="n">currentIndex</span><span class="p">);</span>
                <span class="n">currentIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">currentIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
            <span class="p">}</span> 
        <span class="p">}</span>
            

        <span class="n">T</span> <span class="nf">deleteMin</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">T</span> <span class="n">returnElement</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">T</span> <span class="n">lastElement</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">--</span><span class="n">currentSize</span><span class="p">];</span>
            <span class="n">data</span><span class="p">[</span><span class="n">currentSize</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">returnElement</span><span class="p">;</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastElement</span><span class="p">;</span>
            <span class="n">min</span> <span class="n">minOne</span><span class="p">;</span>
            <span class="n">minOne</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">minOne</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">minOne</span><span class="p">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">currentSize</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">minOne</span> <span class="o">=</span> <span class="n">minInOneSubTree</span><span class="p">(</span><span class="n">minOne</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">minOne</span><span class="p">.</span><span class="n">exist</span><span class="p">)</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">minOne</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">returnElement</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">print</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">currentSize</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="k">struct</span> <span class="nc">min</span>
        <span class="p">{</span>
            <span class="n">T</span> <span class="n">data</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">exist</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 
        <span class="p">};</span>
        
        <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">CAPACITY</span> <span class="o">=</span> <span class="mi">61</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">currentSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">data</span><span class="p">[</span><span class="n">CAPACITY</span><span class="p">];</span>

        <span class="kt">bool</span> <span class="nf">swap</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            

            <span class="kt">bool</span> <span class="n">isChanged</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">preIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
            <span class="n">T</span> <span class="n">temp</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">preIndex</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">isChanged</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">preIndex</span><span class="p">];</span>
                <span class="n">data</span><span class="p">[</span><span class="n">preIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
                <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">isChanged</span><span class="p">;</span>
        <span class="p">}</span>


        <span class="n">min</span> <span class="nf">minInOneSubTree</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">min</span> <span class="n">minOne</span><span class="p">;</span>
            <span class="n">minOne</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
            <span class="n">minOne</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">minOne</span><span class="p">.</span><span class="n">data</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">minOne</span><span class="p">.</span><span class="n">exist</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">minOne</span><span class="p">;</span>
            <span class="p">}</span>
           
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">minOne</span><span class="p">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="p">{</span>
                    <span class="n">minOne</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">minOne</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">minOne</span><span class="p">;</span>
        <span class="p">}</span>

<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">quadHeap</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">testHeap</span><span class="p">;</span>
   
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Test&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">testHeap</span><span class="p">.</span><span class="n">deleteMin</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">testHeap</span><span class="p">.</span><span class="n">deleteMin</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">testHeap</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">testHeap</span><span class="p">.</span><span class="n">deleteMin</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">testHeap</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><h2 id="小结">小结</h2>
<p>  写出来没错就好，也算进步了一点~</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>图片来自Mark A. Weiss - Data Structures and Algorithm Analysis in C++-Pearson (2014) <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>图片来自Mark A. Weiss - Data Structures and Algorithm Analysis in C++-Pearson (2014) <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
		</item>
		
		<item>
			<title>约瑟夫环的两种设计——结构化设计与OOP | 学习记录</title>
			<link>https://www.ironhao.top/posts/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1/</link>
			<pubDate>Sun, 14 Mar 2021 20:42:34 +0800</pubDate>
			
			<guid>https://www.ironhao.top/posts/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1/</guid>
			<description>周末赶了一个关于程序设计的作业，题目让我们分别用结构化设计与基于面向对象的设计思路来完成约瑟夫环的问题，刚好顺便复习下链表，以下是一点过程记</description>
			<content type="html"><![CDATA[<p>  周末赶了一个关于程序设计的作业，题目让我们分别用结构化设计与基于面向对象的设计思路来完成约瑟夫环的问题，刚好顺便复习下链表，以下是一点过程记录。</p>
<h2 id="约瑟夫环的实现">约瑟夫环的实现</h2>
<h4 id="结构化设计">结构化设计</h4>
<p>  这一块网络上的资料也很多，我这里提供一种方法。总的思路就是使用累加器来记录报数，到指定人数后将对应的人“杀死”，一直循环直至剩下一人，返回存活人的号码。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">nrOfPeople</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>   <span class="c1">// 总人数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">nrOfDead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// 死亡人数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">M</span><span class="p">;</span>  <span class="c1">// 题目所指定的M，报数报到M即死亡
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 第index个人
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 当前报数
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">survival</span><span class="p">[</span><span class="n">nrOfPeople</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>  <span class="c1">// 记录第n个人是否死亡
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Input M &#34;</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">M</span><span class="p">;</span>

    <span class="c1">// 初始化，全部人一开始都活着
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nrOfPeople</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">survival</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 开始筛选
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Dead: &#34;</span><span class="p">;</span>
    <span class="k">do</span>
    <span class="p">{</span>
        <span class="n">index</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">nrOfPeople</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">survival</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">number</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="o">==</span> <span class="n">M</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
            <span class="n">survival</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="n">nrOfDead</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">nrOfDead</span> <span class="o">!=</span> <span class="n">nrOfPeople</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 筛选至只剩一人结束
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 输出幸存的人所处位置
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Left one: &#34;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="n">nrOfPeople</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">survival</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h4 id="基于面向对象oop">基于面向对象（OOP）</h4>
<p>  根据我目前对OOP的理解，就是将问题分为许多个小问题，再将其封装成类，一个类解决一个问题。在这个约瑟夫环问题中，我分了三类：</p>
<ul>
<li>整个约瑟夫环的过程（JosephusProblem）</li>
<li>约瑟夫环中的人（PeopleInJos）</li>
<li>报数器（Number)</li>
</ul>
<p>  和结构化设计解决约瑟夫环的思路类似，将不同的内容分类塞入这三类里。JosephusProblem中，我们要控制游戏的过程，所以相应的初始化，以及需要的变量，包括调用其他两个类的两个变量，总人数、死亡人数，以及一个指向队首的指针（因为我使用了循环链表来存储人）。PeopleInJos中，存放每个人所必须的信息，在这里只有两个，存活与否（isSurvival)和他对应的号码（index），当然，因为类要封装，都必须设置相应的方法来调用到这些私有变量。Number中很简单，就是累加，到点了就返回相应的提示并重置，这个我集成在同一个方法（bool out()）里了。以下是具体代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// JosephusProblemOOP.cpp:
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;JosephusProblem.cpp&#34;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>   
    <span class="n">JosephusProblem</span> <span class="n">j</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">41</span><span class="p">);</span>
    <span class="n">j</span><span class="p">.</span><span class="n">initializa</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">.</span><span class="n">start</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// JosephusProblem.cpp:
</span><span class="c1"></span><span class="cp">#pragma once
</span><span class="cp">#include</span> <span class="cpf">&#34;PeopleInJos.cpp&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;Number.cpp&#34;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">JosephusProblem</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">JosephusProblem</span><span class="p">()</span>
        <span class="p">{</span>

        <span class="p">}</span>

        <span class="n">JosephusProblem</span><span class="p">(</span><span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PeopleInJos</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">num</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Number</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">nrOfPeople</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">nrOfDead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">initializa</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">PeopleInJos</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nrOfPeople</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">temp</span><span class="o">-&gt;</span><span class="n">setNext</span><span class="p">(</span><span class="k">new</span> <span class="n">PeopleInJos</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">temp</span><span class="o">-&gt;</span><span class="n">setNext</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="nf">start</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">tempI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">currentP</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="k">do</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">currentP</span><span class="o">-&gt;</span><span class="n">survival</span><span class="p">())</span>
                <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">num</span><span class="o">-&gt;</span><span class="n">out</span><span class="p">())</span>
                    <span class="p">{</span>
                        <span class="n">currentP</span><span class="o">-&gt;</span><span class="n">kill</span><span class="p">();</span>
                        <span class="n">nrOfDead</span><span class="o">++</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">currentP</span> <span class="o">=</span> <span class="n">currentP</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">nrOfDead</span> <span class="o">!=</span> <span class="n">nrOfPeople</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            
            <span class="n">currentP</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nrOfPeople</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">currentP</span><span class="o">-&gt;</span><span class="n">survival</span><span class="p">())</span>
                <span class="p">{</span>
                    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">currentP</span> <span class="o">=</span> <span class="n">currentP</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span> 
        <span class="n">Number</span><span class="o">*</span> <span class="n">num</span><span class="p">;</span>
        <span class="n">PeopleInJos</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">PeopleInJos</span><span class="o">*</span> <span class="n">currentP</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nrOfPeople</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nrOfDead</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Number.cpp:
</span><span class="c1"></span><span class="cp">#pragma once
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Number</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Number</span><span class="p">()</span>
        <span class="p">{</span>

        <span class="p">}</span>
        
        <span class="n">Number</span><span class="p">(</span><span class="kt">int</span> <span class="n">M</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">currentN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">setM</span> <span class="o">=</span> <span class="n">M</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="nf">out</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">currentN</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">currentN</span> <span class="o">&gt;=</span> <span class="n">setM</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">currentN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">currentN</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">setM</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// PeopleInJos.cpp:
</span><span class="c1"></span><span class="cp"># pragma once
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">PeopleInJos</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">PeopleInJos</span><span class="p">()</span>
        <span class="p">{</span>

        <span class="p">}</span>

        <span class="n">PeopleInJos</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">isSurvival</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">PeopleInJos</span><span class="o">*</span> <span class="nf">getNext</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">setNext</span><span class="p">(</span><span class="n">PeopleInJos</span><span class="o">*</span> <span class="n">next</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="nf">survival</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">isSurvival</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">kill</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">isSurvival</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">PeopleInJos</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">isSurvival</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
<span class="p">};</span>

</code></pre></div><h2 id="一些想法">一些想法</h2>
<p>  毕竟是开学初，刚开始系统的学习OOP设计思路，也许上面的类划分不够细致，不过程序跑起来后，感觉还是不错的，代码个人看着也还是比较清晰的。当然基于OOP设计的程序还是有点问题的，使用了指针却没有手动内存释放，会导致内存泄漏等。这些就留待下次有空完成吧~</p>
]]></content>
		</item>
		
		<item>
			<title>完善博客的第一步</title>
			<link>https://www.ironhao.top/posts/%E5%AE%8C%E5%96%84%E5%8D%9A%E5%AE%A2/</link>
			<pubDate>Sat, 13 Mar 2021 15:55:59 +0800</pubDate>
			
			<guid>https://www.ironhao.top/posts/%E5%AE%8C%E5%96%84%E5%8D%9A%E5%AE%A2/</guid>
			<description>​ 趁着周末，把之前刚刚搭建好的博客完善下~大部分的内容主题已经满足了，剩下的就是部署到github page上了。 目标 部署到github pag</description>
			<content type="html"><![CDATA[<p>​		趁着周末，把之前刚刚搭建好的博客完善下~大部分的内容主题已经满足了，剩下的就是部署到github page上了。</p>
<h2 id="目标">目标</h2>
<ul>
<li>部署到github page上，实现对外开放</li>
<li>绑定域名</li>
<li>使用PicGo来实现快速上传图片至图床</li>
</ul>
<h2 id="过程">过程</h2>
<h4 id="部署">部署</h4>
<p>​		部署还是比较方便的，网上有很多教程，这里我讲讲我的方法：</p>
<ol>
<li>
<p>在github上创建一个新的仓库，命名为yourname.github.io；</p>
</li>
<li>
<p>鉴于github推出了自己的桌面程序（GitHub Desktop），我们可以直接使用这个程序来绑定仓库。在网页新创一个仓库后，github会提示你如</p>
<p>下图所示内容，我们选择“Set up in Desktop&quot;,就可以打开程序，然后选择路径为你的博客需要上传的部分。（如我用的hugo，就设置路径为&hellip;/public）</p>
<p>PS: 绑定时本地文件夹里必须为空</p>
<p><img src="https://i.loli.net/2021/03/13/pPiUaoxF7eZcfRq.png" alt=""></p>
</li>
<li>
<p>完成，一切正常的话，接下来你就可以输入网址 <a href="http://yourname.github.io/">http://yourname.github.io/</a> 访问你的博客了</p>
</li>
</ol>
<h4 id="绑定域名">绑定域名</h4>
<p>​		在仓库的setting里，找到关于Github Page的设置，如下图所示</p>
<p><img src="https://i.loli.net/2021/03/13/XqZUMOgKGtdy2ks.png" alt=""></p>
<p>​		在Custom domain里，输入你的域名，顺便开启强制HTTPS。</p>
<p>​		另一方面，在cmd里输入 ping yourname.github.io，找到对应的ip，在域名那边添加两条解析，如下图所示，一条CNAME指向github分给你的域名，另一条A指向对应的ip。</p>
<p><img src="https://i.loli.net/2021/03/13/YPibhprVyURIMc8.png" alt=""></p>
<p>​		到这里，域名绑定算是完成了。但是打开网页，发现证书无效，显示网页为“不安全”状态。这怎么能忍，于是我决定配置Cloudflare来使用HTTPS，具体流程官网会提供的，<a href="https://dash.cloudflare.com/sign-up">点我转至Cloudflare官网</a>。</p>
<p>​		其中最后需要修改下DNS服务器，像万网点击“管理” → “DNS修改”就能找到了。</p>
<h4 id="picgo绑定">PicGo绑定</h4>
<p>​		PicGo在Github上搜索后就可以找到对应的项目仓库，进行下载。</p>
<p>​		我使用的图床是SM.MS，注册后点击右上角“User”→“Dashboard”→“API Token”→“Generate Secret Token”生成需要的密钥，然后复制到picgo对应的位置即可。</p>
<h2 id="结尾">结尾</h2>
<p>​		过程有些曲折，不过解决了就好~</p>
<p>​		参考文章：https://zhuanlan.zhihu.com/p/37752930</p>
]]></content>
		</item>
		
		<item>
			<title>反反复复的日常</title>
			<link>https://www.ironhao.top/posts/firstday/</link>
			<pubDate>Fri, 12 Mar 2021 20:09:01 +0800</pubDate>
			
			<guid>https://www.ironhao.top/posts/firstday/</guid>
			<description>​ 认认真真的静下心来学习。 ​ 反反复复的玩了不少博客框架，每次都是三分钟热度，搭完之后就闲置在那了。上一个用typecho的博客，搭了快一年，</description>
			<content type="html"><![CDATA[<p>​	认认真真的静下心来学习。</p>
<p>​	反反复复的玩了不少博客框架，每次都是三分钟热度，搭完之后就闲置在那了。上一个用typecho的博客，搭了快一年，服务器都要到期了，也没写几篇文章，有点失败。这次打算转github-page来部署博客，不用花多余的钱去买服务器，也不用担心博客消失、转移等一系列麻烦的事情。</p>
<p>​	在这里稍稍的写一下自己博客的用处吧：</p>
<ul>
<li>
<p>作为一名软工大二的学生，用博客记录下自己平时学习所得，顺带巩固</p>
</li>
<li>
<p>平日里看了不少电影，在博客里写一些观后感</p>
</li>
<li>
<p>记录生活</p>
<p><img src="https://i.loli.net/2021/03/12/a5jBz9Gmt32QdHp.jpg" alt="VXqlb7r1_橙色云插画.jpg"></p>
</li>
</ul>
]]></content>
		</item>
		
	</channel>
</rss>
