<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on IronHao</title>
		<link>https://ironhao-github-io.pages.dev/posts/</link>
		<description>Recent content in Posts on IronHao</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-cn</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Thu, 02 Jun 2022 21:32:25 +0800</lastBuildDate>
		<atom:link href="https://ironhao-github-io.pages.dev/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Bag, Stack and Queue的构造与运用|Algorithms, Part1|第二周</title>
			<link>https://ironhao-github-io.pages.dev/posts/bag_stack_and_queue/</link>
			<pubDate>Thu, 02 Jun 2022 21:32:25 +0800</pubDate>
			
			<guid>https://ironhao-github-io.pages.dev/posts/bag_stack_and_queue/</guid>
			<description>引言 记录一下刷Coursera上《Algorithms, Part1》课程的所学内容。主要包括复现一些课上经典的数据结构与算法（C++），以及</description>
			<content type="html"><![CDATA[<h1 id="引言">引言</h1>
<p>记录一下刷Coursera上《Algorithms, Part1》课程的所学内容。主要包括复现一些课上经典的数据结构与算法（C++），以及每周课程作业的部分（Java）。如有错误之处，欢迎纠正。</p>
<p>对应的Github链接：<a href="https://github.com/IronHao/MyAlgorithmBook">IronHao/MyAlgorithmBook (github.com)</a></p>
<h1 id="正文">正文</h1>
<p>本周内容比较多，分两篇来总结。这是第一部分，主要包含<code>Bag</code>, <code>Stack</code> and <code>Queue</code>的内容。</p>
<h2 id="课程内容">课程内容</h2>
<p><code>Bag</code>, <code>Stack</code> and <code>Queue</code>是最基础的三个数据结构，我们后续更复杂的算法和数据结构都基于这几个数据结构。</p>
<p>在具体学习了解各个数据结构之前，书本上给我们指明了数据结构的三个最优设计目标：</p>
<ol>
<li>它可以处理任意类型的数据；</li>
<li>所需的空间总是和集合的大小成正比；</li>
<li>操作所需的时间总是和集合的大小无关。</li>
</ol>
<p>这次在代码实现上，我使用模板类（template）来实现泛型的效果[为了实现目标1]。同时为了代码的整洁，我将头文件（.h）与源文件（.cpp）分离。</p>
<blockquote>
<p>这中间还遇到了一些小问题，具体可以<a href="https://www.ironhao.top/posts/undefined_reference_to_in_cplusplus/">查看这边</a>。</p>
<p>另外因为我使用偷懒的办法（再导入<code>.cpp</code>文件）去解决这个问题，为了防止重复编译，要在每个文件开头写上<code>#pragma once</code>保证只执行一次编译。</p>
</blockquote>
<p>另外，为了简化内容，我并没有对一些极端情况进行异常处理，如栈为空时尝试从栈顶弹出元素，正常应该抛出一个栈为空的异常报错，然而我选择默认弹出一个<code>T()</code>的返回值。</p>
<p>接下来让我们逐个看一看。</p>
<h3 id="node">Node</h3>
<p>因为在这里我会分别使用**链式存储（链表）<strong>和</strong>顺序存储（数组）*<em>两种方法去实现这几个数据结构</em>（Bag仅用链表，因为数组实现感觉也没什么特别的）*。所以我们需要先实现一下链表中的这个结点类<code>Node</code>。</p>
<blockquote>
<p>顺带总结下链表和数组各自的优劣：（来自书本）</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td>通过索引可以直接访问任意元素</td>
<td>在初始化时就需要知道元素的数量</td>
</tr>
<tr>
<td>链表</td>
<td>使用的空间大小和元素数量成正比</td>
<td>需要通过引用访问任意元素（存引用需要增加内存开销）</td>
</tr>
</tbody>
</table>
</blockquote>
<p>这个数据结构应该包含两个基本的变量：</p>
<ul>
<li><code>T _val</code>：一个T类型的值。</li>
<li><code>Node&lt;T&gt;* _next</code>：一个指向下一个结点的指针，没有则设为<code>nullptr</code>（空）。</li>
</ul>
<p>大致如图所示：</p>
<p><img src="https://s2.loli.net/2022/06/05/IwnBWM5jeaX1CPF.png" alt=""></p>
<p>实现代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Node.h */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cm">/* The one node in Linked-list */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Node</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">T</span> <span class="n">_val</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_next</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Node</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">);</span>
    <span class="n">Node</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">next</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Node</span><span class="p">();</span>

    <span class="cm">/* Get methods */</span>
    <span class="n">T</span> <span class="nf">getVal</span><span class="p">();</span>
    <span class="n">Node</span><span class="o">*</span> <span class="nf">getNext</span><span class="p">();</span>
    
    <span class="cm">/* Set methods */</span>
    <span class="kt">void</span> <span class="nf">setVal</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">setNext</span><span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">next</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Node.cpp */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;Node.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Node</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">setVal</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">setNext</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Node</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">setVal</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">setNext</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">Node</span><span class="p">()</span> <span class="p">{};</span>

<span class="cm">/* Get methods */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">getVal</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_val</span><span class="p">;</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">getNext</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_next</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Set methods */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">setVal</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">_val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
    
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">setNext</span><span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span> <span class="n">_next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><h3 id="bag">Bag</h3>
<p>背包（Bag）是一种<strong>不支持从中删除元素</strong>的集合数据类型，同时，背包里的元素也<strong>不存在确定的拿取（访问）顺序</strong>。</p>
<p>它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素，且这些元素的处理顺序应该是不重要的。</p>
<p>这个数据结构应该包含以下的几个基本方法：</p>
<ul>
<li><code>void add(T val)</code>：将一个元素添加到包中。</li>
<li><code>bool isEmpty()</code>：判断包是否为空。</li>
<li><code>int size()</code>：返回背包中的元素数量。</li>
<li><code>T* elements()</code>：返回一个装有背包中所有元素的数组。</li>
</ul>
<p>因为背包并没有明确它的访问顺序，在<code>add()</code>中的添加位置也可以任意。考虑到我这边是使用链表来实现，所以我会在链表头部插入新节点，这样每次添加的时间复杂度为常数$O(1)$，减少开销。<code>elements()</code>的话，我选择按照链表的顺序从头逐个读取并存入数组。</p>
<p>实现代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Bag.h */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;Node.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;Node.cpp&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cm">/* 
</span><span class="cm"> * Bag data structure, no specific store way, here we use linked-list to store the data.
</span><span class="cm"> * It has only add() method, no remove() method.
</span><span class="cm"> * The element in bag has no specific order.
</span><span class="cm"> */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Bag</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_size</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Bag</span><span class="p">();</span>
    <span class="o">~</span><span class="n">Bag</span><span class="p">();</span>

    <span class="cm">/* Insert in the head, no need to traverse, time complexity: O(1) */</span> 
    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">);</span>

    <span class="cm">/* Return whether the bag is empty or not */</span>
    <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">();</span>

    <span class="cm">/* Return the number of elements in bag */</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="p">();</span>

    <span class="cm">/* Store the value in array and return */</span>
    <span class="n">T</span><span class="o">*</span> <span class="nf">elements</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Bag.cpp */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;Bag.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Bag</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">_head</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">Bag</span><span class="p">()</span> <span class="p">{}</span>

<span class="cm">/* Insert in the head, no need to traverse, time complexity: O(1) */</span> 
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">setNext</span><span class="p">(</span><span class="n">_head</span><span class="p">);</span>
    <span class="n">_head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">_size</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return whether the bag is empty or not */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isEmpty</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Return the number of elements in bag */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Store the value in array and return */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">*</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">elements</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">_size</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">_head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ans</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">getVal</span><span class="p">();</span> 
        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><h3 id="stack">Stack</h3>
<p>栈（Stack），或者叫做下压栈，是一种<strong>基于后进先出（LIFO, Last In Frist Out）策略</strong>的集合类型。</p>
<p>生活中电子邮箱的默认排序（最新的在最上面），以及浏览器的回退按钮等，都基于栈这种后进先出的策略实现。</p>
<p>它默认最新的（刚放到栈顶的）拥有最高的优先级。</p>
<p><img src="https://s2.loli.net/2022/06/05/TX2sJCSGdAqkxBE.png" alt=""></p>
<p>这个数据结构应该包含以下的几个基本方法：</p>
<ul>
<li><code>void push(T item)</code>：将一个元素添加到栈顶。</li>
<li><code>T pop()</code>：弹出（返回并删除）栈顶的元素。</li>
<li><code>T top()</code>：返回栈顶的元素，不删除。</li>
<li><code>bool isEmpty()</code>：查看栈是否为空，为空返回<code>true</code>，否则返回<code>false</code>。</li>
<li><code>int count()</code>：返回栈内的元素个数。</li>
</ul>
<p>栈这边的话既可以使用链式存储，也可以使用顺序存储。对于这两种，分别有一些细节需要考虑：</p>
<ul>
<li>
<p>对于<u>链式存储</u>，我们只需要维护一个指向栈顶元素的指针和元素总数的<code>Int</code>型变量即可。元素总数没啥好说，<code>push</code>+1，<code>pop</code>-1即可。栈顶指针的话，我们将其认为为链表头部，每次我们都在头部添加一个新的，删除则是将指针指向下一个然后删除原先的头指针即可。</p>
</li>
<li>
<p>对于<u>顺序存储</u>，我们只需要维护元素总数的<code>Int</code>型变量即可，数组内非空的最后一个元素就是我们的栈顶。关键就在于<strong>数组大小的动态更改</strong>，因为数组本身大小在分配内存时就限定死了，要想改变大小，只能重新分配一个新的数组，并将原先的值逐个复制过去，这是一个比较大的开销，因为需要遍历整个数组（时间复杂度$O(n)$）。我们这里采取的策略是：</p>
<ul>
<li>当数组满了，我们将数组容量翻倍（即$*2$)，并将原来的数据转移到新数组中；</li>
<li>当数组内元素数量减到数组容量的$\frac{1}{4}$时，我们将数组容量减半（即$\frac{1}{2}$）。</li>
</ul>
<p>这是一种比较高效的做法，具体证明就不展开了。</p>
</li>
</ul>
<p>实现代码如下：（<code>ArrayStack</code>表示使用顺序存储，<code>LinkedListStack</code>表示使用链式存储）</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* ArrayStack.h */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cm">/* 
</span><span class="cm"> * Stack data structure, array implementation. FILO.
</span><span class="cm"> */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ArrayStack</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">_arr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_count</span><span class="p">;</span>

    <span class="cm">/* Return whether the stack is full or not */</span>
    <span class="kt">bool</span> <span class="nf">isFull</span><span class="p">();</span>
    <span class="cm">/* Resize the stack to the &#39;newSize&#39; */</span>
    <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="kt">int</span> <span class="n">newSize</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">ArrayStack</span><span class="p">();</span>
    <span class="o">~</span><span class="n">ArrayStack</span><span class="p">();</span>

    <span class="cm">/* Push the &#39;item&#39; to the top of the stack */</span>
    <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">);</span>
    <span class="cm">/* Pop(delete) and return the item in the top of the stack */</span>
    <span class="n">T</span> <span class="nf">pop</span><span class="p">();</span>
    <span class="cm">/* Get the item in the top of the stack, no delete */</span>
    <span class="n">T</span> <span class="nf">top</span><span class="p">();</span>
    <span class="cm">/* Return whether the stack is empty or not */</span>
    <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">();</span>
    <span class="cm">/* Return the size (allocate memory) of the stack */</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="p">();</span>
    <span class="cm">/* Return the number of items in the stack */</span>
    <span class="kt">int</span> <span class="nf">count</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* ArrayStack.cpp */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;ArrayStack.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">ArrayStack</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">_arr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">_size</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">ArrayStack</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">_arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return whether the stack is full or not */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isFull</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span> <span class="o">==</span> <span class="n">_count</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Resize the stack to the &#39;newSize&#39; */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">resize</span><span class="p">(</span><span class="kt">int</span> <span class="n">newSize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">tempArr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">newSize</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">tempArr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">_arr</span><span class="p">;</span>
    <span class="n">_arr</span> <span class="o">=</span> <span class="n">tempArr</span><span class="p">;</span>
    <span class="n">_size</span> <span class="o">=</span> <span class="n">newSize</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Push the &#39;item&#39; to the top of the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Resize the array(Double the size of array) if the stack is full
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">isFull</span><span class="p">())</span>
        <span class="n">resize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
    <span class="c1">// Push the item
</span><span class="c1"></span>    <span class="n">_arr</span><span class="p">[</span><span class="n">_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Pop(delete) and return the item in the top of the stack. Return nullptr if the stack is empty */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Pop the item
</span><span class="c1"></span>    <span class="n">T</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_arr</span><span class="p">[</span><span class="o">--</span><span class="n">_count</span><span class="p">];</span>
    <span class="c1">// Resize the array(halve the size) if the count is one-quarter full
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="p">()</span> <span class="o">==</span> <span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">resize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the item in the top of the stack, no delete. Return nullptr if the stack is empty */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">top</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">T</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_arr</span><span class="p">[</span><span class="n">_count</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> 
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span> 
<span class="p">}</span>

<span class="cm">/* Return whether the stack is empty or not */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isEmpty</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Return the size (allocate memory) of the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Return the number of items in the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">count</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* LinkedListStack.h */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;Node.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;Node.cpp&#34;</span><span class="cp">
</span><span class="cp"></span>

<span class="cm">/* 
</span><span class="cm"> * Stack data structure, linked-list implementation. FILO.
</span><span class="cm"> */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">LinkedListStack</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="cm">/* data */</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_top</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_count</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">LinkedListStack</span><span class="p">();</span>
    <span class="o">~</span><span class="n">LinkedListStack</span><span class="p">();</span>

    <span class="cm">/* Push the &#39;item&#39; to the top of the stack */</span>
    <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">);</span>
    <span class="cm">/* Pop(delete) and return the item in the top of the stack */</span>
    <span class="n">T</span> <span class="nf">pop</span><span class="p">();</span>
    <span class="cm">/* Get the item in the top of the stack, no delete */</span>
    <span class="n">T</span> <span class="nf">top</span><span class="p">();</span>
    <span class="cm">/* Return whether the stack is empty or not */</span>
    <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">();</span>
    <span class="cm">/* Return the number of items in the stack */</span>
    <span class="kt">int</span> <span class="nf">count</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* LinkedListStack.cpp */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;LinkedListStack.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">LinkedListStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">LinkedListStack</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">_top</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">LinkedListStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">LinkedListStack</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">delete</span> <span class="n">_top</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Push the &#39;item&#39; to the top of the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">LinkedListStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="n">temp</span><span class="o">-&gt;</span><span class="n">setNext</span><span class="p">(</span><span class="n">_top</span><span class="p">);</span>
    <span class="n">_top</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="n">_count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Pop(delete) and return the item in the top of the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">LinkedListStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_top</span><span class="o">-&gt;</span><span class="n">getVal</span><span class="p">();</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">_top</span><span class="p">;</span>
        <span class="n">_top</span> <span class="o">=</span> <span class="n">_top</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
        <span class="k">delete</span> <span class="n">temp</span><span class="p">;</span>
        <span class="n">_count</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the item in the top of the stack, no delete */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">LinkedListStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">top</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_top</span><span class="o">-&gt;</span><span class="n">getVal</span><span class="p">();</span>
    <span class="k">else</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return whether the stack is empty or not */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">LinkedListStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isEmpty</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Return the number of items in the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">LinkedListStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">count</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><h3 id="queue">Queue</h3>
<p>队列（Queue），或者叫做先进先出队列，是一种基于先进先出（FIFO, First In First Out）策略的集合类型。</p>
<p>它就像我们生活中排队一样，遵从先来后到的原则，认为最早来的拥有最高的优先级。</p>
<p>通过使用队列，我们可以在保存元素的同时保存它们的相对顺序，即让它们的入列顺序与出列顺序保持一致（栈则刚好相反，为逆序）。</p>
<p><img src="https://s2.loli.net/2022/06/05/4tFNep1XKqU2Jag.png" alt=""></p>
<p>这个数据结构应该包含以下的几个基本方法：</p>
<ul>
<li><code>void enqueue(T item)</code>：将一个元素添加到队尾。</li>
<li><code>T dequeue()</code>：弹出（返回并删除）队头的元素。</li>
<li><code>T first()</code>：返回队头的元素，不删除。</li>
<li><code>T last()</code>：返回队尾的元素，不删除。</li>
<li><code>bool isEmpty()</code>：查看队列是否为空，为空返回<code>true</code>，否则返回<code>false</code>。</li>
<li><code>int count()</code>：返回队列内的元素个数。</li>
</ul>
<p>同样，队列这边的话也既可以使用链式存储，也可以使用顺序存储。对于这两种，分别有一些细节需要考虑：</p>
<ul>
<li>
<p>对于<u>链式存储</u>，我们只需要维护两个指针（一个指向队头的元素，一个指向队尾的元素）和元素总数的<code>Int</code>型变量即可。元素总数没啥好说，<code>enqueue</code>+1，<code>dequeue</code>-1即可。指针的话就是简单的在删除和添加操作时更新头和尾指针即可。正常情况下，<code>enqueue</code>只用更新队尾指针，<code>dequeue</code>只用更新队头指针。但要注意为空的边界条件（从一个元素变为零个/从零个变为一个），此时两个指针都需要维护。</p>
</li>
<li>
<p>对于<u>顺序存储</u>，我们有两种选择：</p>
<ul>
<li>维护一个指向队头的下标+元素总数的<code>Int</code>型变量，队尾由<code>队头+元素总数-1</code>得出。</li>
<li>维护一个指向队头的下标+一个指向队尾的下标，元素总数由<code>队尾-队头+1</code>得出。</li>
</ul>
<p>在这里我选择第一种。另外，为了充分利用空间，我们将数组理解为一个<strong>环</strong>（即对于大小为$n$的数组$arr$，最后一个数组元素$arr[n-1]$的下一个元素为$arr[0]$)。所以我们这里要用到取余<code>%</code>来实现，具体见代码。</p>
</li>
</ul>
<p>实现代码如下：（<code>ArrayQueue</code>表示使用顺序存储，<code>LinkedListQueue</code>表示使用链式存储）</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* ArrayQueue.h */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cm">/* 
</span><span class="cm"> * Queue data structure, linked-list implementation. FIFO.
</span><span class="cm"> */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ArrayQueue</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">_arr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_count</span><span class="p">;</span>

    <span class="cm">/* Return whether the queue is full or not */</span>
    <span class="kt">bool</span> <span class="nf">isFull</span><span class="p">();</span>
    <span class="cm">/* Resize the queue to the &#39;newSize&#39; */</span>
    <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="kt">int</span> <span class="n">newSize</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ArrayQueue</span><span class="p">();</span>
    <span class="o">~</span><span class="n">ArrayQueue</span><span class="p">();</span>

    <span class="cm">/* Insert a new item onto queue(tail of the queue) */</span>
    <span class="kt">void</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">);</span>
    <span class="cm">/* Remove and return the item least recently added(head of the queue) */</span>
    <span class="n">T</span> <span class="nf">dequeue</span><span class="p">();</span>
    <span class="cm">/* Return the item least recently added without removing */</span>
    <span class="n">T</span> <span class="nf">first</span><span class="p">();</span>
    <span class="cm">/* Return the item latest recently added without removing */</span>
    <span class="n">T</span> <span class="nf">last</span><span class="p">();</span>
    <span class="cm">/* Return whether the queue is empty or not */</span>
    <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">();</span>
    <span class="cm">/* Return the size (allocate memory) of the queue */</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="p">();</span>
    <span class="cm">/* Return the number of items in queue */</span>
    <span class="kt">int</span> <span class="nf">count</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* ArrayStack.cpp */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;ArrayStack.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">ArrayStack</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">_arr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">_size</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">ArrayStack</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">_arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return whether the stack is full or not */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isFull</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span> <span class="o">==</span> <span class="n">_count</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Resize the stack to the &#39;newSize&#39; */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">resize</span><span class="p">(</span><span class="kt">int</span> <span class="n">newSize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">tempArr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">newSize</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">tempArr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">_arr</span><span class="p">;</span>
    <span class="n">_arr</span> <span class="o">=</span> <span class="n">tempArr</span><span class="p">;</span>
    <span class="n">_size</span> <span class="o">=</span> <span class="n">newSize</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Push the &#39;item&#39; to the top of the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Resize the array(Double the size of array) if the stack is full
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">isFull</span><span class="p">())</span>
        <span class="n">resize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
    <span class="c1">// Push the item
</span><span class="c1"></span>    <span class="n">_arr</span><span class="p">[</span><span class="n">_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Pop(delete) and return the item in the top of the stack. Return nullptr if the stack is empty */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Pop the item
</span><span class="c1"></span>    <span class="n">T</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_arr</span><span class="p">[</span><span class="o">--</span><span class="n">_count</span><span class="p">];</span>
    <span class="c1">// Resize the array(halve the size) if the count is one-quarter full
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="p">()</span> <span class="o">==</span> <span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">resize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the item in the top of the stack, no delete. Return nullptr if the stack is empty */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">top</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">T</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_arr</span><span class="p">[</span><span class="n">_count</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> 
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span> 
<span class="p">}</span>

<span class="cm">/* Return whether the stack is empty or not */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isEmpty</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Return the size (allocate memory) of the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Return the number of items in the stack */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">count</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* LinkedListQueue.h */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;Node.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;Node.cpp&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 
</span><span class="cm"> * Queue data structure, linked-list implementation. FIFO.
</span><span class="cm"> */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">LinkedListQueue</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_first</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_last</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_count</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">LinkedListQueue</span><span class="p">();</span>
    <span class="o">~</span><span class="n">LinkedListQueue</span><span class="p">();</span>

    <span class="cm">/* Insert a new item onto queue(tail of the queue) */</span>
    <span class="kt">void</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">);</span>
    <span class="cm">/* Remove and return the item least recently added(head of the queue) */</span>
    <span class="n">T</span> <span class="nf">dequeue</span><span class="p">();</span>
    <span class="cm">/* Return the item least recently added without removing */</span>
    <span class="n">T</span> <span class="nf">first</span><span class="p">();</span>
    <span class="cm">/* Return the item latest recently added without removing */</span>
    <span class="n">T</span> <span class="nf">last</span><span class="p">();</span>
    <span class="cm">/* Return whether the queue is empty or not */</span>
    <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">();</span>
    <span class="cm">/* Return the number of items in queue */</span>
    <span class="kt">int</span> <span class="nf">count</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* LinkedListQueue.cpp */</span>

<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;LinkedListQueue.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">LinkedListQueue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">_first</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">_last</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">LinkedListQueue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">delete</span> <span class="n">_first</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">_last</span><span class="p">;</span>
<span class="p">}</span>
    
<span class="cm">/* Insert a new item onto queue(tail of the queue) */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">enqueue</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">_last</span><span class="o">-&gt;</span><span class="n">setNext</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
        <span class="n">_last</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">_last</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_first</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
            <span class="n">_first</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">_count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
    
<span class="cm">/* Remove and return the item least recently added(head of the queue) */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">dequeue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_first</span><span class="o">-&gt;</span><span class="n">getVal</span><span class="p">();</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">_first</span><span class="p">;</span>
        <span class="n">_first</span> <span class="o">=</span> <span class="n">_first</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
        <span class="k">delete</span> <span class="n">temp</span><span class="p">;</span>
        <span class="n">_count</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return the item least recently added without removing */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">first</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_first</span><span class="o">-&gt;</span><span class="n">getVal</span><span class="p">();</span>
    <span class="k">else</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* Return the item latest recently added without removing */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>    
<span class="n">T</span> <span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">last</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">_last</span><span class="o">-&gt;</span><span class="n">getVal</span><span class="p">();</span>
    <span class="k">else</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">T</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return whether the queue is empty or not */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isEmpty</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_first</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Return the number of items in queue */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">LinkedListQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">count</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><h3 id="应用">应用</h3>
<p>应用方面，课程中主要重点讲解了Dijkstra的双栈算术表达式求值算法。该算法使用了使用了两个栈，一个存储值，一个存储运算符。它仅对未省略括号的算术表达式有效。且我们为了简化，只考虑二元运算符。它主要要处理下列四种情况：</p>
<ul>
<li>对于操作数（值），它将其压入到操作数（值）栈中；</li>
<li>对于运算符，它将其压入到运算符栈中；</li>
<li>对于左括号，虽然为运算符，我们将其忽略；</li>
<li>对于右括号，我们从运算符栈中弹出栈顶运算符，并从值栈中，弹出栈顶两个元素（只考虑二元运算符），并根据弹出的运算符，对两个弹出的值进行相应的计算操作。</li>
</ul>
<p>这里有几个细节需要注意：</p>
<ul>
<li>因为我们是从左到右扫描，逐个读取处理字符串。所以对于弹出的两个值元素，先弹出的应该是运算符右侧的值（后压入），后弹出的则是运算符左侧的值（先压入）。</li>
<li>课程中是逐个读取字符串，一个字符串代表一个值/运算符。我改为直接输入整行算数表达式。则需要逐个字符处理，对应的，为了判断输入的值是否完整（比如我输入了98,要判断是98而不是9），我们要往前看一位，若接下来一位仍为数字，则将当前结果×10并继续读下一位，若不是，则表明值已经读取完整，将其压入值栈中。</li>
</ul>
<p>具体代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* ArithmeticExpressionUsingStack.cpp */</span>

<span class="cp">#include</span> <span class="cpf">&#34;ArrayStack.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;ArrayStack.cpp&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="cm">/*
</span><span class="cm"> *  Dijkstra&#39;s two-stack arithmetic expression evaluation.
</span><span class="cm"> *  One stack for operator, another stack for value.
</span><span class="cm"> *  ・Value: push onto the value stack.
</span><span class="cm"> *  ・Operator: push onto the operator stack.
</span><span class="cm"> *  ・Left parenthesis: ignore.
</span><span class="cm"> *  ・Right parenthesis: pop operator and two values; push the result of applying that operator to those values onto the operand stack.
</span><span class="cm"> *  
</span><span class="cm"> *  WARNING: Arithmetic expressions that ignore parentheses are not considered! And we only care about binary operator (operator with two values).
</span><span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">string</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;*</span> <span class="n">ops</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">vals</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">try</span>
    <span class="p">{</span>
        
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">input</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="p">{</span>
            <span class="c1">// Ignore the &#39;(&#39; and &#39; &#39;[space].
</span><span class="c1"></span>            <span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39; &#39;</span><span class="o">:</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="c1">// Pop the operator in &#39;ops&#39; stack and do the operator.
</span><span class="c1"></span>            <span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="o">:</span>
            <span class="p">{</span>
                <span class="kt">char</span> <span class="n">op</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">();</span>
                <span class="c1">// if (op == char())
</span><span class="c1"></span>                <span class="c1">//     throw &#34;Illegal arithmetic expression!&#34;;
</span><span class="c1"></span>                <span class="kt">int</span> <span class="n">valR</span> <span class="o">=</span> <span class="n">vals</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">();</span> 
                <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="n">valR</span> <span class="o">=</span> <span class="n">vals</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">()</span> <span class="o">+</span> <span class="n">valR</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="n">valR</span> <span class="o">=</span> <span class="n">vals</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">()</span> <span class="o">-</span> <span class="n">valR</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">)</span> <span class="n">valR</span> <span class="o">=</span> <span class="n">vals</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">()</span> <span class="o">*</span> <span class="n">valR</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">valR</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="k">throw</span> <span class="s">&#34;The divisor cannot be zero!&#34;</span><span class="p">;</span>
                    <span class="n">valR</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">()</span> <span class="o">/</span> <span class="n">valR</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">vals</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">(</span><span class="n">valR</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Arithmetic operator
</span><span class="c1"></span>            <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span>
                <span class="n">ops</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="c1">// Value 
</span><span class="c1"></span>            <span class="k">case</span> <span class="sc">&#39;0&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;1&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;2&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;3&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;4&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;5&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;6&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;7&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;8&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;9&#39;</span><span class="o">:</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
                <span class="c1">// One char of lookahead to deter whether it is a connected number or not. If the value is clear (found the end), push to the &#39;vals&#39; stack.
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">input</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">||</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="sc">&#39;9&#39;</span> <span class="o">||</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">vals</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">throw</span> <span class="s">&#34;Illegal characters in input!&#34;</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">throw</span> <span class="s">&#34;Illegal arithmetic expression!&#34;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">vals</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm"> *  A simple test:
</span><span class="cm"> *  Input the arithmetic expression(one line) and evaluate it, it will print the answer and wait for next input.
</span><span class="cm"> *  Input &#39;End&#39; to exit.
</span><span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;*</span> <span class="n">ops</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">vals</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayStack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">string</span> <span class="n">input</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">input</span> <span class="o">==</span> <span class="s">&#34;End&#34;</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Ans: &#34;</span><span class="o">&lt;&lt;</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">input</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="课程作业">课程作业</h2>
<p>这个课程作业要求我们实现两个特殊的队列形式，<code>deque</code>和<code>randomized queue</code>。[具体可以看这](<a href="https://coursera.cs.princeton.edu/algs4/assignments/queues/specification.php">Programming Assignment 2: Queues (princeton.edu)</a>)。</p>
<blockquote>
<p><strong>Dequeue.</strong> A <em>double-ended queue</em> or <em>deque</em> (pronounced “deck”) is a generalization of a stack and a queue that supports adding and removing items from either the front or the back of the data structure.</p>
</blockquote>
<p><code>Dequeue</code>实际上就是可以双头添加/删除的队列，比起<code>queue</code>队头删除队尾添加多了些选择。</p>
<blockquote>
<p><strong>Randomized queue.</strong> A <em>randomized queue</em> is similar to a stack or queue, except that the item removed is chosen uniformly at random among items in the data structure.</p>
</blockquote>
<p><code>Randomized queue</code>的话，把<code>queue</code>队头删除的特性改为了队列中随机删除。增加了随机性。</p>
<p>代码就不贴了，具体可以看Github仓库里的。</p>
<h1 id="后记">后记</h1>
<p>学习参考内容：</p>
<p><a href="https://www.coursera.org/learn/algorithms-part1">Algorithms, Part1 - Coursera</a></p>
<p><a href="https://book.douban.com/subject/19952400/">《算法 第四版》</a></p>
]]></content>
		</item>
		
		<item>
			<title>使用vscode编译C&#43;&#43;多文件(包含模板类)|解决Undefined reference to报错</title>
			<link>https://ironhao-github-io.pages.dev/posts/undefined_reference_to_in_cplusplus/</link>
			<pubDate>Thu, 26 May 2022 19:57:21 +0800</pubDate>
			
			<guid>https://ironhao-github-io.pages.dev/posts/undefined_reference_to_in_cplusplus/</guid>
			<description>遇到的问题 今天复现“Algorithms, Part1“课程里“Bags, Queues, And Stacks”里的内容时，想打算顺手重新熟悉了解下C++的一些特</description>
			<content type="html"><![CDATA[<h1 id="遇到的问题">遇到的问题</h1>
<p>今天复现“Algorithms, Part1“课程里“Bags, Queues, And Stacks”里的内容时，想打算顺手重新熟悉了解下C++的一些特性，其中就包括模板类（template）[想要使用它来实现泛型的效果]和头文件（.h）与源文件（.cpp）分离。</p>
<p>我在头文件中定义类，同时使用模板类方便支持多种数据类型，并在源文件中将方法补充完整。大致代码如下所示：（默认命名空间声明最好不要放在头文件，错误示范&hellip;）</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Bag.h */</span>
<span class="cp">#pragma once
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;Node.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;Node.cpp&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cm">/* 
</span><span class="cm"> * Bag data structure, no specific store way, here we use linked-list to store the data.
</span><span class="cm"> * It has only add() method, no remove() method.
</span><span class="cm"> * The element in bag has no specific order.
</span><span class="cm"> */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Bag</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_size</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Bag</span><span class="p">();</span>
    <span class="o">~</span><span class="n">Bag</span><span class="p">();</span>

    <span class="cm">/* Insert in the head, no need to traverse, time complexity: O(1) */</span> 
    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">);</span>

    <span class="cm">/* Return whether the bag is empty or not */</span>
    <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">();</span>

    <span class="cm">/* Return the number of elements in bag */</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="p">();</span>

    <span class="cm">/* Store the value in array and return */</span>
    <span class="n">T</span><span class="o">*</span> <span class="nf">elements</span><span class="p">();</span>
<span class="p">};</span>


<span class="cm">/* Bag.cpp */</span>
<span class="cp">#include</span> <span class="cpf">&#34;Bag.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Bag</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">_head</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">Bag</span><span class="p">()</span> <span class="p">{}</span>

<span class="cm">/* Insert in the head, no need to traverse, time complexity: O(1) */</span> 
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">setNext</span><span class="p">(</span><span class="n">_head</span><span class="p">);</span>
    <span class="n">_head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">_size</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return whether the bag is empty or not */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isEmpty</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Return the number of elements in bag */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Store the value in array and return */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">*</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">elements</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">_size</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">_head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ans</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">getVal</span><span class="p">();</span> 
        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><p>但是当代码敲完，准备运行测试时，却发现出现<code>undefined reference to</code>的报错提示，告诉我找不到对应的方法。</p>
<p><img src="https://s2.loli.net/2022/05/26/s3xbtIKWy9Vp61q.png" alt=""></p>
<h1 id="解决思路">解决思路</h1>
<p>于是我就开动我的小脑筋（<del>指把报错提示复制粘贴到搜索引擎里</del>），开始寻找解决方案。</p>
<h2 id="c多文件编译配置">C++多文件编译配置</h2>
<p>首先可能是我们没有编译全部的<code>.cpp</code>文件，只编译了当前执行的<code>main.cpp</code>文件，导致找不到对应的类。</p>
<p>这个解决方法也很简单，我使用的是<code>vscode</code>，只要修改对应的配置文件，即可。我使用的是<code>Code-runner</code> 插件，打开设置，找到他的<code>Executor Map</code>设置，并点击<code>在settings.json中编辑</code>。</p>
<p><img src="https://s2.loli.net/2022/05/26/mAPcWltb1usEVj4.png" alt=""></p>
<p>修改<code>&quot;cpp&quot;</code>栏的<code>$fileName</code>为<code>*.cpp</code>（表示当前目录下所有<code>.cpp</code>文件）即可。</p>
<p><img src="https://s2.loli.net/2022/05/26/9SC6lgAwOVHBULP.png" alt=""></p>
<blockquote>
<p>如果使用配置文件的话，修改<code>tasks.json</code>文件中<code>args</code>栏的<code>${file}</code>为<code>${fileDirname}\\*.cpp</code>也能达到类似的效果。</p>
</blockquote>
<p>但是到此，问题还没有得到解决。</p>
<h2 id="模板的缺陷">模板的缺陷</h2>
<blockquote>
<p>The problem is that a function template is not a function. It&rsquo;s a template for creating functions as needed.</p>
<p>So for a template to work, the compiler intuitively needs two pieces of information: The template itself, and the type that should be substituted into it.</p>
<p>When you declare the function template without defining it, you&rsquo;re only telling the compiler that such a template exists, but not what it looks like. That&rsquo;s not enough for the compiler to be able to instantiate it, it has to be able to see the full definition as well. The usual solution is to put the entire template in a header that can be included where needed.</p>
</blockquote>
<p><code>template</code>意味着在模板被真正使用之前，编译器并不知道模板套用的是什么类型，应该分配多少空间。而我们指定的类型<code>T</code>在编译之前就相当于是个占位符。而不同的类型对应着不同的类，我们需要让编译器在编译的时候就知道并具体的定义它们，而不只给一个抽象的类型<code>T</code>。</p>
<p>我的程序在编译的时候，编译器只知道类型<code>T</code>版本的<code>Bag</code>类，而不知道<code>int</code>版本的<code>Bag</code>类。所以我们要修改代码，让编译器知道我们需要类型版本的<code>Bag</code>类。</p>
<p>而我们只导入了<code>.h</code>文件，<code>.h</code>相当于是一种声明，它方便编译器来找到对应的实现。我们没有真正的定义，编译器无法编译，自然就会出现<code>Undefined reference to</code>报错了。</p>
<p>我们有两种思路去解决：</p>
<ul>
<li>
<p>将<code>.cpp</code>文件也导入<code>main.cpp</code>中（或者将对应的方法放到<code>.h</code>文件里也是一样的）。这样会让编译器明确模板类的定义。</p>
</li>
<li>
<p>或者显式申明用到的类型，例如直接写出</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">Bag</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Bag</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">_head</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    
<span class="p">}</span>
</code></pre></div><p>但是这样，好像就丧失了泛型的意义所在？</p>
</li>
</ul>
<p>但无论如何，问题得到了解决，这就足够了~</p>
<h1 id="参考链接">参考链接</h1>
<p><a href="https://blog.csdn.net/qq_41652566/article/details/124029456?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0-124029456-blog-117439217.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">C/C++ VScode 多文件编译配置(undefined reference to ‘xxx‘错误) - CSDN</a></p>
<p><a href="https://stackoverflow.com/questions/648900/c-templates-undefined-reference">C++ templates, undefined reference - stackoverflow</a></p>
<p>[<a href="https://www.dazhuanlan.com/topics/node2">后端</a> C++: 模板类编译过程中出现“undefined reference to”问题](<a href="https://www.dazhuanlan.com/ooxx52douban/topics/1547428">https://www.dazhuanlan.com/ooxx52douban/topics/1547428</a>)</p>
]]></content>
		</item>
		
		<item>
			<title>Union-Find问题的解决与方案迭代|Algorithms, Part1|第一周</title>
			<link>https://ironhao-github-io.pages.dev/posts/union_find/</link>
			<pubDate>Tue, 17 May 2022 18:21:17 +0800</pubDate>
			
			<guid>https://ironhao-github-io.pages.dev/posts/union_find/</guid>
			<description>引言 记录一下刷Coursera上《Algorithms, Part1》课程的所学内容。主要包括复现一些课上经典的数据结构与算法（C++），以及</description>
			<content type="html"><![CDATA[<h1 id="引言">引言</h1>
<p>记录一下刷Coursera上《Algorithms, Part1》课程的所学内容。主要包括复现一些课上经典的数据结构与算法（C++），以及每周课程作业的部分（Java）。如有错误之处，欢迎纠正。</p>
<h1 id="正文">正文</h1>
<h2 id="课程内容">课程内容</h2>
<p>这周分为两块，一部分为算法课程总的介绍，另一部分则是Union-Find的内容。</p>
<p>课程介绍的部分就不再赘述。我们主要来看看Union-Find的部分。</p>
<p>不过在此之前，我们要知道，算法的目的是为了高效解决问题。我们根据问题情况建立模型，然后找到一种速度尽可能快，消耗内存尽可能少的算法去解决。当然这不可能是一蹴而就的。我们需要不断迭代算法，直到满足需求。接下来的Union-Find就是一个贯彻这一思想的案例。</p>
<h3 id="union-find">Union-Find</h3>
<p>实质就是一个动态连通性的问题，判断两个点之间是否能连通。动态就体现我们可以动态地连接两个点（当然应该也能断开两个点的连接，但是在这里为了简化问题，没有考虑）。于是根据这个问题，我们需要设计一个数据结构来保存程序已知的所有整数对的足够多的信息，并用他们来判断一对新对象是否是相连的。</p>
<p>这个数据结构应该包含以下的几个基本方法：</p>
<ul>
<li><code>void unionNode(int node1, int node2)</code>：连接两个结点。如果已经连接了，就不再做任何操作。</li>
<li><code>int find(int node)</code>：返回该结点的根节点（或者说组号）。</li>
<li><code>int count()</code>：返回组数。</li>
<li><code>bool isConnected(int node1, int node2)</code>：判断两个点是否连接。</li>
</ul>
<h4 id="方案一---quick-find">方案一 |  Quick-Find</h4>
<p>我们使用一个数组来记录它的根结点（或者可以理解为它的组号），只要组号相同，就说明点是连通的。所以我们核心就是<strong>维护这个记录根结点的数组</strong>。当然为了记录组数，我们还需要维护一个组数的变量。</p>
<p><img src="https://s2.loli.net/2022/05/15/ke7ib2xpufKzvGa.png" alt=""></p>
<p>所以我们对于这几个基本方法的实现思路如下：</p>
<ul>
<li><code>void unionNode(int node1, int node2)</code>：判断两个结点的根结点是否一致，一致表示已连接，不用再做操作，否则就遍历根结点数组，让<code>node1</code>同组的根节点都变成<code>node2</code>的根节点。同时连接后，组数减一，所以别忘了组数的变量。</li>
<li><code>int find(int node)</code>：返回根结点数组的对应值即可。</li>
<li><code>int count()</code>：返回表示组数的变量即可。</li>
<li><code>bool isConnected(int node1, int node2)</code>：判断两个点是否连接只需要判断他们根结点（组号）是否一致，一致就是连接，反之不是。</li>
</ul>
<p>除此之外，还加了<code>void Show()</code>这个方法，方便测试调用查看结果。</p>
<p>实现代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Use the quick-find method */</span>
<span class="k">class</span> <span class="nc">QuickFindUF</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">_root</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_count</span><span class="p">;</span>

    <span class="kt">int</span> <span class="nf">length</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_msize</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span> <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">QuickFindUF</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
        <span class="c1">// Init, the root is itself.
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">_root</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">_count</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">QuickFindUF</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">_root</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Check whether these nodes are connected */</span> 
    <span class="kt">bool</span> <span class="nf">isConnected</span><span class="p">(</span><span class="kt">int</span> <span class="n">node1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span> <span class="o">==</span> <span class="n">find</span><span class="p">(</span><span class="n">node2</span><span class="p">);</span> <span class="p">}</span>

    <span class="cm">/* Union the node1 and node2, let all node&#39;s root is same as node1_root to node2_root */</span>
    <span class="kt">void</span> <span class="nf">unionNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">node1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">node1_root</span> <span class="o">=</span> <span class="n">_root</span><span class="p">[</span><span class="n">node1</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">node2_root</span> <span class="o">=</span> <span class="n">_root</span><span class="p">[</span><span class="n">node2</span><span class="p">];</span>
        <span class="c1">// Same root, already connect, no need to do anything
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">node1_root</span> <span class="o">==</span> <span class="n">node2_root</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="c1">// Connect
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">_root</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_root</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">node1_root</span><span class="p">)</span>
                <span class="n">_root</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">node2_root</span><span class="p">;</span>
        <span class="n">_count</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Return the identification(root) of the specific node */</span>
    <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span>  <span class="p">{</span> <span class="k">return</span> <span class="n">_root</span><span class="p">[</span><span class="n">node</span><span class="p">];</span> <span class="p">}</span>

    <span class="cm">/* Return the number of connected component */</span> 
    <span class="kt">int</span> <span class="nf">count</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span><span class="p">;</span> <span class="p">}</span>

    <span class="cm">/* Show the nubmer of nodes, the number of connected component and the &#34;nodes -&gt; it&#39;s root&#34; */</span>
    <span class="kt">void</span> <span class="nf">show</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">_root</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The nodes number: &#34;</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The connected components number: &#34;</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">count</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Node</span><span class="se">\t</span><span class="s"> -&gt; it&#39;s root&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s"> -&gt; &#34;</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><p>这个算法的问题就在于，每次<code>unionNode()</code>时，如果要连接，那就需要遍历整个数组。如果每次都要连接，那么时间开销将会是$O(n^2)$级别的。这是我们不能接受的。</p>
<h4 id="方案二--quick-union">方案二 | Quick-Union</h4>
<p>于是我们提出了方案二，这次我们<strong>不直接指向根节点，而是指向它的父结点，即从叶子开始，构造了一棵树</strong>。而如何判断是根节点呢，只要它的父亲指向它本身即可。</p>
<p>所以我们对于这几个基本方法的实现思路如下：</p>
<ul>
<li><code>void unionNode(int node1, int node2)</code>：判断两个结点的根结点是否一致，一致表示已连接，不用再做操作，否则就让<code>node1</code>的树作为子树并入到<code>node2</code>的树中，即让<code>node1</code>的根结点的父亲指向<code>node2</code>的根结点。</li>
<li><code>int find(int node)</code>：返回根结点数组的对应值即可。</li>
<li><code>int count()</code>：返回表示组数的变量即可。</li>
<li><code>bool isConnected(int node1, int node2)</code>：与方案一一样，判断两个点是否连接只需要判断他们根节点（组号）是否一致，一致就是连接，反之不是。</li>
</ul>
<p>另外，在这边我还添加了一个<code>int depth(int node)</code>的函数，返回<code>node</code>结点所对应的深度，方便最后在<code>show</code>函数里显示树最大的深度（这个与我们判断时遍历的最坏情况息息相关）。</p>
<p>实现代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Use the quick-union method */</span>
<span class="k">class</span> <span class="nc">QuickUnionUF</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">_parent</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_count</span><span class="p">;</span>

    <span class="kt">int</span> <span class="nf">length</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_msize</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span> <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">depth</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">dp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">_parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">!=</span> <span class="n">node</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">_parent</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
            <span class="n">dp</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">QuickUnionUF</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
        <span class="c1">// Init, the parent is itself.
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">_parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">_count</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">QuickUnionUF</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">_parent</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Check whether these nodes are connected */</span> 
    <span class="kt">bool</span> <span class="nf">isConnected</span><span class="p">(</span><span class="kt">int</span> <span class="n">node1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span> <span class="o">==</span> <span class="n">find</span><span class="p">(</span><span class="n">node2</span><span class="p">);</span> <span class="p">}</span>

    <span class="cm">/* Union the node1 and node2, let node1_root&#39;s parent to node2_root */</span>
    <span class="kt">void</span> <span class="nf">unionNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">node1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">node1_root</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">node1</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">node2_root</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">node2</span><span class="p">);</span>
        <span class="c1">// Same root, already connect, no need to do anything
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">node1_root</span> <span class="o">==</span> <span class="n">node2_root</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="c1">// Connect, let node1 be the subtree of the node2
</span><span class="c1"></span>        <span class="n">_parent</span><span class="p">[</span><span class="n">node1_root</span><span class="p">]</span> <span class="o">=</span> <span class="n">node2_root</span><span class="p">;</span>
        <span class="n">_count</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Return the identification(root) of the specific node */</span>
    <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span>  
    <span class="p">{</span>
        <span class="c1">// To find the root, which parent is itself.
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">_parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">!=</span> <span class="n">node</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">_parent</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Return the number of connected component */</span> 
    <span class="kt">int</span> <span class="nf">count</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_count</span><span class="p">;</span> <span class="p">}</span>

    <span class="cm">/* Show the nubmer of nodes, the number of connected component, the depth and the &#34;nodes -&gt; it&#39;s root&#34; */</span>
    <span class="kt">void</span> <span class="nf">show</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">_parent</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The nodes number: &#34;</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The connected components number: &#34;</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">count</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">dp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">tempD</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">tempD</span> <span class="o">=</span> <span class="n">depth</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tempD</span> <span class="o">&gt;</span> <span class="n">dp</span><span class="p">)</span>
                <span class="n">dp</span> <span class="o">=</span> <span class="n">tempD</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The depth: &#34;</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Node</span><span class="se">\t</span><span class="s"> -&gt; it&#39;s root&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s"> -&gt; &#34;</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><p>这样我们每次连接的时候，也只需要执行一步操作了，不需要再整个数组遍历过来。但是我们增加了<code>find()</code>的消耗，同时由于<code>unionNode()</code>里我们也需要使用<code>find()</code>去找根节点。这个方法还是不行。</p>
<p>那么关键在哪？考虑下最坏情况，一颗没有分叉的树，父子都是一对一的，如果从叶子出发，那就需要n次遍历，才能找到根节点。所以我们要想办法缩短这个距离，即让树的高度尽可能的小。</p>
<h4 id="方案三--weighted-quick-union">方案三 | Weighted-Quick-Union</h4>
<p>在这个方案里，我们在连接树的时候，<strong>将树里结点的数量作为权重，越多权重越大</strong>，我们让小权重（结点少）的树作为大权重（结点多）的树的子数。从而保证树的高度尽可能的少，减少<code>find()</code>遍历的次数。<em>（关于结点数与树高度的关系，可以从想象从零开始连接独立的结点，构造这棵树出发。）</em></p>
<p><img src="https://s2.loli.net/2022/05/15/13s54HD8WozSaBw.png" style="zoom: 80%;" /></p>
<p>所以我们对于这几个基本方法的实现思路如下：（其他与方案二保持一致的就不再重复）</p>
<ul>
<li><code>void unionNode(int node1, int node2)</code>：判断两个结点的根结点是否一致，一致表示已连接，不用再做操作，否则就判断两个结点的让<code>node1</code>的树作为子树并入到<code>node2</code>的树中，即让<code>node1</code>的根结点的父亲指向<code>node2</code>的根结点。</li>
</ul>
<p>实现代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*为了减少内容，这边只把与方案二有区别的部分放上来*/</span>

<span class="cm">/* Use the weighted-quick-union method */</span>
<span class="k">class</span> <span class="nc">WeightedQuickUnionUF</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">_size</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">WeightedQuickUnionUF</span><span class="p">(</span><span class="kt">int</span> <span class="n">nrOfNode</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">nrOfNode</span><span class="p">];</span>
        <span class="n">_size</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">nrOfNode</span><span class="p">];</span>
        <span class="c1">// Init, the parent is itself ans size is one(only itself).
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nrOfNode</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
            
        <span class="n">_count</span> <span class="o">=</span> <span class="n">nrOfNode</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="cm">/* Union the node1 and node2, let smaller size node root&#39;s parent to larger size node root */</span>
    <span class="kt">void</span> <span class="nf">unionNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">node1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">node1_root</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">node1</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">node2_root</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">node2</span><span class="p">);</span>
        <span class="c1">// Same root, already connect, no need to do anything
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">node1_root</span> <span class="o">==</span> <span class="n">node2_root</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="c1">// Connect, let the smaller tree be the subtree of the larger tree
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">_size</span><span class="p">[</span><span class="n">node1_root</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">_size</span><span class="p">[</span><span class="n">node2_root</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">_parent</span><span class="p">[</span><span class="n">node1_root</span><span class="p">]</span> <span class="o">=</span> <span class="n">node2_root</span><span class="p">;</span>
            <span class="n">_size</span><span class="p">[</span><span class="n">node2_root</span><span class="p">]</span> <span class="o">+=</span> <span class="n">_size</span><span class="p">[</span><span class="n">node1_root</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">_parent</span><span class="p">[</span><span class="n">node2_root</span><span class="p">]</span> <span class="o">=</span> <span class="n">node1_root</span><span class="p">;</span>
            <span class="n">_size</span><span class="p">[</span><span class="n">node1_root</span><span class="p">]</span> <span class="o">+=</span> <span class="n">_size</span><span class="p">[</span><span class="n">node2_root</span><span class="p">];</span>
        <span class="p">}</span>
            
        <span class="n">_count</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这样我们就可以缩减每次<code>find()</code>所需要的时间了，从$O(n)$变为$O(logN)$，但是，有没有可能实现常数级别的查找呢？</p>
<h4 id="方案四--path-compressed-weighted-quick-union">方案四 | Path-Compressed-Weighted-Quick-Union</h4>
<p>我们可以尝试把路径再一次的压缩，让每次尽可能一次就找到，即让每个结点都直接指向对应树的根结点，同时又不增加过多的额外操作。我们可以<strong>在检查结点的同时将它们直接连接到根结点</strong>。</p>
<p>所以我们对于这几个基本方法的实现思路如下：（其他与方案三保持一致的就不再重复）</p>
<ul>
<li><code>int find(int node)</code>：返回根结点数组的对应值，同时将该棵树内的所有结点都指向根节点。（当然我们首先要知道根节点才能指向，所以要用两个独立的循环，一个找根节点，找完后再重新循环一遍，更改根结点。从时间复杂度的角度上分析，只是乘了个两倍的系数，整体不影响。）</li>
</ul>
<p>实现代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*为了减少内容，这边只把与方案二有区别的部分放上来*/</span>

<span class="cm">/* Use the path-compressed-weighted-quick-union method */</span>
<span class="k">class</span> <span class="nc">WeightedCompressedQuickUnionUF</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="cm">/* Return the identification(root) of the specific node */</span>
    <span class="kt">int</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span>  
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="c1">// To find the root, which parent is itself.
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">_parent</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">!=</span> <span class="n">root</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">_parent</span><span class="p">[</span><span class="n">root</span><span class="p">];</span>
        <span class="c1">// Let all its children link directly to the root.
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">_parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">!=</span> <span class="n">node</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">_parent</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这样我们就实现了一个简单的路径压缩~这个算法的时间复杂度的均摊开销为$O(1)$，成功实现常数级别的查找与连接了。</p>
<p>这就是我们一步步细化算法的过程了。</p>
<h2 id="课程作业">课程作业</h2>
<p>本周的课程作业内容为<a href="https://coursera.cs.princeton.edu/algs4/assignments/percolation/specification.php">Percolation</a>。通俗理解就是判断顶部的水能否一层层过滤渗透到最底下一层。我们使用网格来表示，每个格子都有打开或者关闭两种选项。我们设每个格子被打开的概率为$p$，我们想知道，当$p$恰好为何值时，刚好处于渗透状态。</p>
<p>当然具体内容描述还是得看上方网站介绍。</p>
<p>代码具体内容就是根据他提供的UF类，解决这个具体问题。</p>
<p>关键有两点：</p>
<ol>
<li>为了方便判断顶部到底部是否流通，我们可以构造两个虚拟的点，分别连接顶部一层的结点和底部一层的结点，这样我们只要判断这两个点是否连通即可。</li>
<li>当我们将一个结点打开时，要考虑将其与四周（上下左右）方位的已打开结点相连。</li>
</ol>
<p>代码就不贴了，具体可以看Github仓库里的。</p>
<h1 id="后记">后记</h1>
<p>学习参考内容：</p>
<p><a href="https://www.coursera.org/learn/algorithms-part1">Algorithms, Part1 - Coursera</a></p>
<p><a href="https://book.douban.com/subject/19952400/">《算法 第四版》</a></p>
]]></content>
		</item>
		
		<item>
			<title>Tilemap里瓦块的动态添加与删除|Unity2D学习日记（三）</title>
			<link>https://ironhao-github-io.pages.dev/posts/tileaddanddelete/</link>
			<pubDate>Tue, 08 Feb 2022 23:00:00 +0800</pubDate>
			
			<guid>https://ironhao-github-io.pages.dev/posts/tileaddanddelete/</guid>
			<description>引言 个人学习积累中，如有任何问题与错误，欢迎指出与讨论。 这系列将会记录我在搭建自己的2D平台游戏时遇到的一些问题与解决方案，核心目的均为更好</description>
			<content type="html"><![CDATA[<h2 id="引言">引言</h2>
<blockquote>
<p>个人学习积累中，如有任何问题与错误，欢迎指出与讨论。</p>
</blockquote>
<p>这系列将会记录我在搭建自己的2D平台游戏时遇到的一些问题与解决方案，核心目的均为<strong>更好的游戏体验与更棒的代码逻辑结构</strong>。<em>所有代码基于C#与Unity。</em></p>
<h2 id="正文">正文</h2>
<blockquote>
<p><strong>Tilemap</strong> 组件是一个存储和处理<strong>瓦片资源</strong>以便创建 2D 关卡的系统。—— Unity Documentation</p>
</blockquote>
<p>使用网格构造关卡与处理机制极大地方便了我的游戏制作。但是网上关于Tilemap的教程多集中于编辑器上的可视化操作，对于在脚本中如何动态处理瓦块的内容，却很少提及，就算提及，也不是很全。结合我这一段时间的学习积累，我觉得，也是时候讲讲我是如何处理运用Tilemap的了。本文集中于<strong>代码动态处理</strong>上，偏资料整理向。</p>
<h3 id="前置条件">前置条件</h3>
<p>光靠Unity自带的<code>2D Tilemap Editor</code>当然是不够的，我们还需要它的扩展包，<code>2D Tilemap Extras</code>，这个扩展包中提供了更多样的刷子与瓦块，方便一些功能的实现。我在这里集中使用<code>Rule Tile</code>为例。</p>
<p>除此之外，我们还需要了解一些基本的类与方法。当然，详细的需要去找对应的文档。</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">using</span> <span class="nn">UnityEngine.Tilemaps</span><span class="p">;</span>	<span class="c1">// 导入
</span><span class="c1"></span>
<span class="cm">/* 使用的类 */</span>
<span class="k">public</span> <span class="n">RuleTile</span> <span class="n">tile_1</span><span class="p">;</span>	<span class="c1">// ruleTile对应的类，该类继承自TileBase，意味着它也可以使用父类的一些基本方法
</span><span class="c1"></span><span class="k">public</span> <span class="n">Tilemap</span> <span class="n">tilemap_1</span><span class="p">;</span>	<span class="c1">// tilemap对应的类，该类继承自GridLayout，可以使用父类的一些基本方法
</span><span class="c1"></span>
<span class="cm">/* 放置与删除指定位置瓦块 */</span>
<span class="n">tilemap_1</span><span class="p">.</span><span class="n">SetTile</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">tile_1</span><span class="p">);</span>	<span class="c1">// 将&#39;tile_1&#39;瓦块放置到&#39;tilemap_1&#39;瓦块地图的&#39;pos&#39;位置上
</span><span class="c1"></span><span class="n">tilemap_1</span><span class="p">.</span><span class="n">SetTile</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span> 	<span class="c1">// 将tilemap_1&#39;瓦块地图的&#39;pos&#39;位置上的瓦块清空
</span><span class="c1"></span>
<span class="cm">/* 位置转换 */</span>
<span class="n">Vector3Int</span> <span class="n">currentPos</span> <span class="p">=</span> <span class="n">tilemap_1</span><span class="p">.</span><span class="n">WorldToCell</span><span class="p">(</span><span class="n">worldPos</span><span class="p">)</span>	<span class="c1">// 将对应的&#39;worldPos&#39;世界坐标转换为对应的瓦块地图的坐标，为Vector3Int类型
</span><span class="c1"></span>    
<span class="cm">/* 获取位置上的瓦块 */</span>
<span class="n">TileBase</span> <span class="n">tile_2</span> <span class="p">=</span> <span class="n">tilemap_1</span><span class="p">.</span><span class="n">GetTile</span><span class="p">(</span><span class="n">currentPos</span><span class="p">);</span>
<span class="n">RuleTile</span> <span class="n">tile_3</span> <span class="p">=</span> <span class="n">tilemap_1</span><span class="p">.</span><span class="n">GetTile</span><span class="p">&lt;</span><span class="n">RuleTile</span><span class="p">&gt;(</span><span class="n">currentPos</span><span class="p">);</span>	<span class="c1">// 获取&#39;tilemap_1&#39;中某个单元格的给定&#39;currentPos&#39;位置处的&#39;tile of type RuleTile&#39;
</span></code></pre></div><h3 id="运用--以方块增减为例">运用 | 以方块增减为例</h3>
<p>好了，既然你已经学会拧螺丝了，是时候造个飞机试试看了。嗯，好像是个不太好笑的笑话。</p>
<p>无论如何，通过例子学习肯定是一个好办法。接下来，我会通过我项目中使用过的例子，介绍一些基本方法。</p>
<p><em>需要再次明确的是，这些方法并不一定是最优解，我只能保证其能跑，但不保证效果。</em></p>
<p>这会是一个详尽的例子，涉及Tilemap与Unity其他方法的结合运用，同时包括我自己思考完善机制的路线，方便大家体会研究。</p>
<h4 id="基本功能实现">基本功能实现</h4>
<p>首先给出我们的需求（这是我在GGJ2022所制作的游戏**”胖还是瘦“**的核心玩法）：</p>
<ul>
<li>人物在瘦子状态可以吸收三个可变方块转变为胖子状态，同时也可以在胖子状态释放三个可变方块转变为瘦子状态。</li>
<li>吸收释放方式为发射无碰撞体的子弹</li>
<li>通过鼠标点击确认吸收释放的具体方块</li>
<li>新释放的方块只能添加在原有方块的边上（即周围一圈）</li>
<li>吸收的方块需要是连续的（就像你用一条连线勾选三个方块那样）</li>
</ul>
<p>我们在这里只考虑瓦块相关的问题，关于如何处理胖瘦状态，子弹如何发射、如何确认方向，如何确认碰撞点，我们就默认已经有完美解决方法了。</p>
<p>首先我们看看如何添加释放方块。明确一下，我们所有的处理都会基于坐标数据，常用<code>List&lt;Vector3Int&gt;</code>来存储。</p>
<p>由于释放与添加都需要在原有的可变方块基础上操作，我们首先获得原有的方块数组。这实际上就是一个找最大面积的问题，和LeetCode上的”<a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a>“是同样的思路。</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="na">[SerializeField]</span> <span class="k">private</span> <span class="n">RuleTile</span> <span class="n">slimeTile</span><span class="p">;</span>	<span class="c1">// 对应的可变方块瓦块
</span><span class="c1"></span><span class="na">[SerializeField]</span> <span class="k">private</span> <span class="n">Tilemap</span> <span class="n">slimeTilemap</span><span class="p">;</span>	<span class="c1">// 可变方块放置的瓦块地图
</span><span class="c1"></span>
<span class="c1">// 获得当前射击位置聚集在一起的可变方块的位置信息，结果存在result中
</span><span class="c1"></span><span class="k">void</span> <span class="n">GetMaxTogetherSlimeTile</span><span class="p">(</span><span class="k">ref</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Vector3Int</span><span class="p">&gt;</span> <span class="n">result</span><span class="p">,</span> <span class="n">Vector3Int</span> <span class="n">currentPos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">GetTile</span><span class="p">(</span><span class="n">currentPos</span><span class="p">)</span> <span class="p">!=</span> <span class="n">slimeTile</span> <span class="p">||</span> <span class="n">result</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">currentPos</span><span class="p">))</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">result</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">currentPos</span><span class="p">);</span>
        <span class="n">GetMaxTogetherSlimeTile</span><span class="p">(</span><span class="k">ref</span> <span class="n">result</span><span class="p">,</span> <span class="n">currentPos</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
        <span class="n">GetMaxTogetherSlimeTile</span><span class="p">(</span><span class="k">ref</span> <span class="n">result</span><span class="p">,</span> <span class="n">currentPos</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
        <span class="n">GetMaxTogetherSlimeTile</span><span class="p">(</span><span class="k">ref</span> <span class="n">result</span><span class="p">,</span> <span class="n">currentPos</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
        <span class="n">GetMaxTogetherSlimeTile</span><span class="p">(</span><span class="k">ref</span> <span class="n">result</span><span class="p">,</span> <span class="n">currentPos</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="p">-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 得到对应位置的瓦块类型
</span><span class="c1"></span><span class="n">RuleTile</span> <span class="n">GetTile</span><span class="p">(</span><span class="n">Vector3Int</span> <span class="n">currentPos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">RuleTile</span> <span class="n">ans</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
    <span class="n">Vector3Int</span> <span class="n">location</span> <span class="p">=</span> <span class="n">slimeTilemap</span><span class="p">.</span><span class="n">WorldToCell</span><span class="p">(</span><span class="n">currentPos</span><span class="p">);</span>
    <span class="n">ans</span> <span class="p">=</span> <span class="n">slimeTilemap</span><span class="p">.</span><span class="n">GetTile</span><span class="p">&lt;</span><span class="n">RuleTile</span><span class="p">&gt;(</span><span class="n">location</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>当然这时候你可能会想，我们添加的时候可以选择的方块不是外圈上的嘛，那这怎么获得呢？想一想，可以通过在上面代码的基础上改哦。</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="c1">// 获得当前所有可以添加瓦块的位置，结果存在result中
</span><span class="c1"></span><span class="k">void</span> <span class="n">GetCanAddEmptyTile</span><span class="p">(</span><span class="k">ref</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Vector3Int</span><span class="p">&gt;</span> <span class="n">result</span><span class="p">,</span> <span class="n">Vector3Int</span> <span class="n">currentPos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">List</span><span class="p">&lt;</span><span class="n">Vector3Int</span><span class="p">&gt;</span> <span class="n">currentSlimeTile</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Vector3Int</span><span class="p">&gt;();</span>
    <span class="n">GetMaxTogetherSlimeTile</span><span class="p">(</span><span class="k">ref</span> <span class="n">currentSlimeTile</span><span class="p">,</span> <span class="n">currentPos</span><span class="p">);</span>	<span class="c1">// 先拿到已有的可变方块数组
</span><span class="c1"></span>    <span class="c1">// 找它外圈的
</span><span class="c1"></span>    <span class="k">foreach</span> <span class="p">(</span><span class="n">Vector3Int</span> <span class="n">pos</span> <span class="k">in</span> <span class="n">currentSlimeTile</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">IsCanAddTile</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">pos</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)))</span>   
            <span class="n">result</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">pos</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
       	<span class="k">if</span> <span class="p">(</span><span class="n">IsCanAddTile</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">pos</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)))</span>   
           	<span class="n">result</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">pos</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
       	<span class="k">if</span> <span class="p">(</span><span class="n">IsCanAddTile</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">pos</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="p">-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">)))</span>   
            <span class="n">result</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">pos</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="p">-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">IsCanAddTile</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">pos</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">)))</span>   
            <span class="n">result</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">pos</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 检查该位置能否添加可变方块
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">IsCanAddTile</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="n">Vector3Int</span><span class="p">&gt;</span> <span class="n">result</span><span class="p">,</span> <span class="n">Vector3Int</span> <span class="n">checkPos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 不与已有的冲突且该位置上没有添加过瓦块就可以添加
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(!</span><span class="n">result</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">checkPos</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="n">GetTile</span><span class="p">(</span><span class="n">checkPos</span><span class="p">)</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>但这时候你又会想到，外圈就可能遇到各种问题，比如玩家、地面的瓦块刚好在这外圈上，这时候就不能允许在外圈对应的瓦块上进行修改。这怎么办呢？简单，额外判断一下就好。我们会在后面具体放置时候考虑。</p>
<p>接下来我们就要开始进行放置和吸收操作了。</p>
<p>首先我们考虑<strong>吸收（删除方块）</strong>。这里有几个关键点：</p>
<ul>
<li>鼠标获取对应位置并通过点击确认选择</li>
<li>在完成之前，界面需要保持暂停，等待三个方块选择完毕</li>
</ul>
<p>第二个点，我们很容易就想到使用协程，通过<code>yield return</code>的语句来实现等待效果，第一个点，我们则可以通过Unity自带方法，获取鼠标在场景中的位置，并转换到瓦块地图上。至于点击，<code>Input.GetButton(&quot;Fire1&quot;)</code>即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="n">Vector3</span> <span class="n">mouseWorldPos</span> <span class="p">=</span> <span class="n">Camera</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">ScreenToWorldPoint</span><span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="n">mousePosition</span><span class="p">);</span> <span class="c1">// 获取鼠标位置
</span><span class="c1"></span><span class="n">Vector3Int</span> <span class="n">pos</span> <span class="p">=</span> <span class="n">slimeTilemap</span><span class="p">.</span><span class="n">WorldToCell</span><span class="p">(</span><span class="n">mouseWorldPos</span><span class="p">);</span>	<span class="c1">// 转换
</span></code></pre></div><p>平时，我们会将其封装成一个函数，放在Update里调用。但是，我们其实并不是每一帧都需要鼠标对应的位置，我们只在吸收/释放这个过程中，才需要获取。那么，有什么思路吗？用标识符，在update里if条件语句判断下，或者，直接在<strong>协程里处理每帧调用</strong>？</p>
<p>后者能够获得清楚的代码逻辑，不至于把update里搞得乱乱的，也杜绝了不必要的外部接触。</p>
<p>协程里的<code>Yield return null</code>其实就是表示暂缓一帧，在下一帧的时候再继续处理后续的代码，那么我们就可以利用它和<code>while</code>循环，构造简单的每帧调用。</p>
<p>大致代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="cm">/* 协程里的代码 */</span>
<span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 鼠标位置更新
</span><span class="c1"></span>    <span class="n">Vector3</span> <span class="n">mouseWorldPos</span> <span class="p">=</span> <span class="n">Camera</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">ScreenToWorldPoint</span><span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="n">mousePosition</span><span class="p">);</span>
    <span class="n">Vector3Int</span> <span class="n">pos</span> <span class="p">=</span> <span class="n">slimeTilemap</span><span class="p">.</span><span class="n">WorldToCell</span><span class="p">(</span><span class="n">mouseWorldPos</span><span class="p">);</span>
    
    <span class="c1">// 点击处理
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="n">GetButton</span><span class="p">(</span><span class="s">&#34;Fire1&#34;</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="n">slimeTiles</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="n">canRemoveTiles</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
    <span class="p">{</span>
		<span class="cm">/* 在合适的时候Break跳出 */</span>
    <span class="p">}</span>
	
	<span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>	<span class="c1">// 中断，下一帧继续
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>然后就是<strong>点击处理</strong>里的内容了，除了把当前位置的瓦块消除等基本操作外，还有一个关键点需要我们考虑，<strong>吸收的方块需要是连续的（就像你用一条连线勾选三个方块那样）</strong>，很明显，第一个方块是任意选择，从第二个方块开始，就要根据之前已选的进行判断了。仔细一想，后选的方块不也只能在已选的方块的四周吗，那这，不就是选择外圈的方块吗？！让我们来写一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Vector3Int</span><span class="p">&gt;</span> <span class="n">posOfDeletedSilmeTile</span><span class="p">;</span>	<span class="c1">// 存储已选的方块的坐标数组
</span><span class="c1"></span>
<span class="c1">// 书接上回，就是上方点击处理的具体展示，一开始canRemoveTiles是当前射击位置获得的在一起的全部可变方块
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="n">GetButton</span><span class="p">(</span><span class="s">&#34;Fire1&#34;</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="n">slimeTiles</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="n">canRemoveTiles</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">// 清空对应的瓦块和数据
</span><span class="c1"></span>    <span class="n">slimeTilemap</span><span class="p">.</span><span class="n">SetTile</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
    <span class="n">slimeTiles</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
   	<span class="c1">// 已选方块添加记录
</span><span class="c1"></span>    <span class="n">posOfDeletedSilmeTile</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
    <span class="n">nrOfRemoveDone</span><span class="p">++;</span>
    <span class="c1">// 更新下一次可选的可变方块
</span><span class="c1"></span>    <span class="n">canRemoveTiles</span> <span class="p">=</span> <span class="n">GetCanRemoveSlimeTile</span><span class="p">(</span><span class="n">slimeTiles</span><span class="p">);</span>
    <span class="c1">// 在合适的时候跳出，这里’nrOfRemove = 3‘
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">nrOfRemoveDone</span> <span class="p">&gt;=</span> <span class="n">nrOfRemove</span><span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 基于目前已删除的可变方块，获取当前可删除可变方块
</span><span class="c1"></span><span class="n">List</span><span class="p">&lt;</span><span class="n">Vector3Int</span><span class="p">&gt;</span> <span class="n">GetCanRemoveSlimeTile</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="n">Vector3Int</span><span class="p">&gt;</span> <span class="n">slimeTile</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">List</span><span class="p">&lt;</span><span class="n">Vector3Int</span><span class="p">&gt;</span> <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Vector3Int</span><span class="p">&gt;();</span>
    <span class="n">List</span><span class="p">&lt;</span><span class="n">Vector3Int</span><span class="p">&gt;</span> <span class="n">neighbourTiles</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Vector3Int</span><span class="p">&gt;();</span>
    <span class="c1">// 先获取所有已经删除瓦块的邻居
</span><span class="c1"></span>    <span class="k">foreach</span><span class="p">(</span><span class="n">Vector3Int</span> <span class="n">hasRemovedOne</span> <span class="k">in</span> <span class="n">posOfDeletedSilmeTile</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">neighbourTiles</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">hasRemovedOne</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="p">-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">)))</span>
            <span class="n">neighbourTiles</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">hasRemovedOne</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="p">-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">neighbourTiles</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">hasRemovedOne</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">)))</span>
            <span class="n">neighbourTiles</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">hasRemovedOne</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">neighbourTiles</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">hasRemovedOne</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)))</span>
            <span class="n">neighbourTiles</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">hasRemovedOne</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">neighbourTiles</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">hasRemovedOne</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)))</span>
            <span class="n">neighbourTiles</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">hasRemovedOne</span> <span class="p">+</span> <span class="k">new</span> <span class="n">Vector3Int</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="c1">// 找到既是邻居又是原先瓦块的，就是可以删除的
</span><span class="c1"></span>    <span class="k">foreach</span><span class="p">(</span><span class="n">Vector3Int</span> <span class="n">neighbourOne</span> <span class="k">in</span> <span class="n">neighbourTiles</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slimeTile</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">neighbourOne</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">neighbourOne</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>那这样吸收就解决啦。接下来我们考虑放置。大部分操作是一样的，鼠标选择添加，已有可变方块外围的方块数据我们在之前也给出了获得的方法。不过，还记得我们说过存在的问题吗，<strong>”比如玩家、地面的瓦块刚好在这外圈上，这时候就不能允许在外圈对应的瓦块上进行修改“</strong>。这里我以玩家所处位置为例：</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="cm">/* 障碍物所处的方块位置信息数组 */</span>
<span class="n">List</span><span class="p">&lt;</span><span class="n">Vector3Int</span><span class="p">&gt;</span> <span class="n">barrierStayTiles</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Vector3Int</span><span class="p">&gt;();</span>
<span class="c1">// 根据碰撞体的数据，得到碰撞体四个角对应的瓦块位置信息并添加到数组中
</span><span class="c1"></span><span class="n">BoxCollider2D</span> <span class="n">playerBoxCollider</span> <span class="p">=</span> <span class="n">player</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">BoxCollider2D</span><span class="p">&gt;();</span>

<span class="n">barrierStayTiles</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">slimeTilemap</span><span class="p">.</span><span class="n">WorldToCell</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="p">+</span> <span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">extents</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="p">-</span> <span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">extents</span><span class="p">.</span><span class="n">y</span><span class="p">)));</span>

<span class="n">barrierStayTiles</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">slimeTilemap</span><span class="p">.</span><span class="n">WorldToCell</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="p">-</span> <span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">extents</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="p">-</span> <span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">extents</span><span class="p">.</span><span class="n">y</span><span class="p">)));</span>

<span class="n">barrierStayTiles</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">slimeTilemap</span><span class="p">.</span><span class="n">WorldToCell</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="p">+</span> <span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">extents</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="p">+</span> <span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">extents</span><span class="p">.</span><span class="n">y</span><span class="p">)));</span>

<span class="n">barrierStayTiles</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">slimeTilemap</span><span class="p">.</span><span class="n">WorldToCell</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="p">-</span> <span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">extents</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="p">+</span> <span class="n">playerBoxCollider</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">extents</span><span class="p">.</span><span class="n">y</span><span class="p">)));</span>
</code></pre></div><p>获得对应的信息后，我们只需要在鼠标点击判断的时候添加一个判断语句<code>!barrierStayTiles.Contains(pos)</code>即可。</p>
<p>到此为止，需求所要的基本功能已经实现。</p>
<h4 id="进一步完善美化">进一步完善美化</h4>
<p>当然我们不可能仅满足于此，这个游戏还太”硬核“了，对玩家不够友好，缺少UI提示，打个比方，玩家怎么知道，他当前选择的方块能不能添加呢，甚至是，玩家怎么知道他当前选择了那个方块呢，鼠标移上去又没有变化。</p>
<p>所以我们还需要使用tilemap去添加一些简易的交互提示。这里以<strong>实现鼠标移动到的瓦块会有一个选择外框</strong>为例。</p>
<p>我们首先需要一个外框的瓦块图片，然后，我们要创建一个新的Tilemap，放在原有Tilemap之上[通过修改<code>Tilemap Renderer</code>组件的<code>Sorting Layer</code>或者<code>Order in Layer</code>(如果他们在同一个图层上)来实现]。</p>
<p><em>PS: <code>Tilemap</code>组件有<code>Color</code>一栏，所以有别的效果别忘了这个哦，比如改颜色、透明度等</em></p>
<p>接着，我们就可以开始写代码了。别忘了，之前我们已经可以实现每帧调用更新鼠标位置了，我们只要在原有基础上进一步完善即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="na">[SerializeField]</span> <span class="k">private</span> <span class="n">Tilemap</span> <span class="n">cursorTilemap</span><span class="p">;</span>	<span class="c1">// 外框所在的Tilemap
</span><span class="c1"></span><span class="na">[SerializeField]</span> <span class="k">private</span> <span class="n">RuleTile</span> <span class="n">frameTile</span><span class="p">;</span>	<span class="c1">// 外框的RuleTile
</span><span class="c1"></span>
<span class="c1">// 更新框的位置，很简单，清空Tilemap，然后指定位置放一块即可
</span><span class="c1"></span><span class="k">void</span> <span class="n">UpdataFrameTile</span><span class="p">(</span><span class="n">Vector3Int</span> <span class="n">currentPos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cursorTilemap</span><span class="p">.</span><span class="n">ClearAllTiles</span><span class="p">();</span>
    <span class="n">cursorTilemap</span><span class="p">.</span><span class="n">SetTile</span><span class="p">(</span><span class="n">currentPos</span><span class="p">,</span> <span class="n">frameTile</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 在对应的位置调用方法 */</span>
<span class="p">...</span>
<span class="n">Vector3</span> <span class="n">mouseWorldPos</span> <span class="p">=</span> <span class="n">Camera</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">ScreenToWorldPoint</span><span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="n">mousePosition</span><span class="p">);</span>
<span class="n">Vector3Int</span> <span class="n">pos</span> <span class="p">=</span> <span class="n">slimeTilemap</span><span class="p">.</span><span class="n">WorldToCell</span><span class="p">(</span><span class="n">mouseWorldPos</span><span class="p">);</span>
<span class="n">UpdataFrameTile</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div><p>是不是觉得很简单？原有框架搭好了，在其基础上更改就是这样方便。</p>
<h4 id="小结">小结</h4>
<p>到此为止，该例子就已展示完毕，碍于篇幅，只展示了一些关键代码，如果觉得太过模糊，可以去<a href="https://www.gmhub.com/game/404">这里</a>下载当时GGJ上传的文件，里面包含完整的项目文件，关键代码在<code>CursorController.cs</code>里，子弹碰撞之类的在<code>BulletContoller.cs</code>里。</p>
<h2 id="后记">后记</h2>
<p>到此为止，本篇就结束了，看着蛮长，其实用来用去也就涉及到了Tilemap里一点点的功能，希望对大家有所帮助。靠着他人提供的轮子，结合一些简单的算法，我们也能很快地完成一个不错的游戏机制。下一篇，我们会就Tilemap的持久化数据存储展开讨论（<del>希望自己不咕吧</del>）。</p>
<p>顺便也纪念下自己第一次参加Game jam类型的活动。</p>
<p>同样，我在学习本文相关内容时，借鉴了不少帖子、视频，包括但不限于：</p>
<p><a href="https://www.youtube.com/watch?v=zABMvbTyEK8&amp;list=PL2vxeJx7wGYE9TkNOTlZJQ4NRqRevPw3h&amp;index=5">Unity: Set Get and Detect tiles in tilemaps! —— Pxl Dev</a></p>
]]></content>
		</item>
		
		<item>
			<title>利用脚本实现全局音效的控制|Unity2D学习日记（二）</title>
			<link>https://ironhao-github-io.pages.dev/posts/audiomanager/</link>
			<pubDate>Fri, 24 Sep 2021 21:16:34 +0800</pubDate>
			
			<guid>https://ironhao-github-io.pages.dev/posts/audiomanager/</guid>
			<description>引言 个人学习积累中，如有任何问题与错误，欢迎指出与讨论。 这系列将会记录我在搭建自己的2D平台游戏时遇到的一些问题与解决方案，核心目的均为更好</description>
			<content type="html"><![CDATA[<h2 id="引言">引言</h2>
<blockquote>
<p>个人学习积累中，如有任何问题与错误，欢迎指出与讨论。</p>
</blockquote>
<p>这系列将会记录我在搭建自己的2D平台游戏时遇到的一些问题与解决方案，核心目的均为<strong>更好的游戏体验与更棒的代码逻辑结构</strong>。<em>所有代码基于C#与Unity。</em></p>
<h2 id="正文">正文</h2>
<blockquote>
<p>恰到好处的音效能够为游戏提供更好的沉浸感。——鲁迅</p>
</blockquote>
<p>音效是游戏创造中的重要一环，恰到好处的音效，能够准确的告诉你，主角在“<strong>做什么</strong>”，又“<strong>遭受了什么</strong>”，为玩家提供足够的信息。但是如何管理是个问题。</p>
<blockquote>
<p>主角扛着几个大音响与数张“唱片”：受伤、跳跃、跑步、攻击&hellip;&hellip;与另一个扛着大音响和唱片的BOSS相遇。他们开启战斗，打着打着，要开启对应的音响，甚至可能还要根据自己的动作切换唱片。</p>
</blockquote>
<p>当然这并不是不行，正式游玩时又不会真的有个大音箱挂在主角身上。但当你调试修改代码时，看着Inspector栏里成堆的组件时，你也许会觉得，这并不是一个好办法。那么，有什么更好的解决方法吗？</p>
<p>使用<strong>一个脚本实现全局管理</strong>，也许是个可行的方法。</p>
<p>惯例，讲一点点的前置小知识。</p>
<h3 id="component组件">Component|组件</h3>
<blockquote>
<p>游戏对象是 Unity Editor 中包含组件的对象。组件定义了该游戏对象的行为。——Unity手册</p>
</blockquote>
<p>组件是Unity中最重要的一块内容，脚本也可以作为组件挂载在物体上。我们需要知道的是，组件，也是可以通过脚本在物体上动态挂载（卸载）的。</p>
<ul>
<li><strong>加载方式</strong>：<code>组件类型 组件名 = gameobject.AddComponent&lt;组件类型&gt;();</code></li>
<li><strong>卸载方式</strong>：<code>Destroy(组件名);</code></li>
</ul>
<p>所以，我们可以通过脚本控制音频，在需要播放的时候生成组件（<em>注：查阅网上资料，也有说动态加载对资源的消耗很大，谨慎使用？</em>），并在音乐播放完毕后删除组件。</p>
<h3 id="枚举类与switch-case语句的组合">枚举类与Switch-case语句的组合</h3>
<p>这是我个人非常喜欢使用的一个组合，写出来的条例清晰，让人debug时心情愉悦（<em>并不</em>）。</p>
<p>为什么要使用枚举类？</p>
<p>通过枚举类来限制范围，配合代码自动补全，减少出错概率，同时，也提高代码的可读性（<em>只要你不瞎取名</em>）。另外，<strong>枚举类里的每个值，本质上是int，所以传入数组时，是以int类型存放的</strong>，也正是利用这个，我们可以实现与Switch-case语句的结合，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">switch</span> <span class="p">(</span><span class="n">Enum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">case</span> <span class="n">Enum</span><span class="p">.</span><span class="n">Name_1</span><span class="p">:</span>
        <span class="cm">/* 内容 */</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Enum</span><span class="p">.</span><span class="n">Name_2</span><span class="p">:</span>
        <span class="cm">/* 内容 */</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Enum</span><span class="p">.</span><span class="n">Name_3</span><span class="p">:</span>
        <span class="cm">/* 内容 */</span>
        <span class="k">break</span><span class="p">;</span>       
<span class="p">}</span>
    
</code></pre></div><p>另外，由于为int值，还可以作为数组等的下标来处理，这方面就留给各位自行研究了。</p>
<h3 id="audiomanager全局音乐管理类">AudioManager|全局音乐管理类</h3>
<p>接下来写我们的脚本吧。为了方便其他脚本快速的调用该类里的内容，我们要使用静态（static）变量，并在一开始就赋值。</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="cm">/* 无特殊说明，代码都在AudioManger类中 */</span>
<span class="k">public</span> <span class="k">static</span> <span class="n">AudioManager</span> <span class="n">instance</span><span class="p">;</span>

<span class="k">private</span> <span class="k">void</span> <span class="n">Awake</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 保证只有一个，丢弃后产生的
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Destroy</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">instance</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="n">DontDestroyOnLoad</span><span class="p">(</span><span class="n">gameObject</span><span class="p">);</span>	<span class="c1">// 避免在场景切换时摧毁该脚本所挂载的物体
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>另外，我们还需要准备好唱片（AudioClip）。</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="cm">/* 简单意思几个，节省篇幅~ */</span>
<span class="cm">/* Header(&#34;在Inspector里的显示内容&#34;)，相当于注释；[SerializeField]用于在Inspector里可视化私有变量，方便赋值 */</span>
<span class="na">[Header(&#34;背景音乐&#34;)]</span>
<span class="na">[SerializeField]</span> <span class="k">private</span> <span class="n">AudioClip</span> <span class="n">musicClip</span><span class="p">;</span>	
<span class="na">
</span><span class="na">[Header(&#34;玩家音效&#34;)]</span>
<span class="na">[SerializeField]</span> <span class="k">private</span> <span class="n">AudioClip</span> <span class="n">runClip_King</span><span class="p">;</span>
</code></pre></div><p>在放歌前，我们还需要做好记录准备，不然局部变量一下子就跑不见了，再找就麻烦了。</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">AudioGroup</span><span class="p">&gt;</span> <span class="n">audioSource_Background</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">AudioGroup</span><span class="p">&gt;();</span> 
<span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">AudioGroup</span><span class="p">&gt;</span> <span class="n">audioSource_King</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">AudioGroup</span><span class="p">&gt;();</span>
</code></pre></div><p>接着，我们要提供一个一键万能按钮。调用它后，会自动生成组件（音响，AudioSource）并播放音效，结束后，自动卸载组件。</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="cm">/* MusicType为我们的枚举类，target表明对应的物体 */</span>
<span class="k">public</span> <span class="k">void</span> <span class="n">PlayMusic</span><span class="p">(</span><span class="n">MusicType</span> <span class="n">musicType</span><span class="p">,</span> <span class="n">GameObject</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">AudioSource</span> <span class="n">tempS</span><span class="p">;</span>
    <span class="n">AudioGroup</span> <span class="n">tempAG</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">musicType</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">MusicType</span><span class="p">.</span><span class="n">Background</span><span class="p">:</span>
            <span class="n">tempS</span> <span class="p">=</span> <span class="n">gameObject</span><span class="p">.</span><span class="n">AddComponent</span><span class="p">&lt;</span><span class="n">AudioSource</span><span class="p">&gt;();</span>
            <span class="n">tempS</span><span class="p">.</span><span class="n">clip</span> <span class="p">=</span> <span class="n">musicClip</span><span class="p">;</span>
            <span class="n">tempS</span><span class="p">.</span><span class="n">Play</span><span class="p">();</span>
            <span class="n">tempS</span><span class="p">.</span><span class="n">loop</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>			<span class="c1">// 背景音乐要循环播放
</span><span class="c1"></span>            <span class="n">tempS</span><span class="p">.</span><span class="n">volume</span> <span class="p">=</span> <span class="m">0.2f</span><span class="p">;</span>
            <span class="n">tempAG</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AudioGroup</span><span class="p">(</span><span class="n">tempS</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
            <span class="n">audioSource_Background</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">tempAG</span><span class="p">);</span>
            <span class="cm">/* 背景音乐不需要卸载，一直存在 */</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">MusicType</span><span class="p">.</span><span class="n">Run_King</span><span class="p">:</span>
            <span class="n">tempS</span> <span class="p">=</span> <span class="n">gameObject</span><span class="p">.</span><span class="n">AddComponent</span><span class="p">&lt;</span><span class="n">AudioSource</span><span class="p">&gt;();</span>	<span class="c1">// 生成组件
</span><span class="c1"></span>            <span class="n">tempS</span><span class="p">.</span><span class="n">clip</span> <span class="p">=</span> <span class="n">runClip_King</span><span class="p">;</span>	<span class="c1">// 确定唱片
</span><span class="c1"></span>            <span class="n">tempS</span><span class="p">.</span><span class="n">volume</span> <span class="p">=</span> <span class="m">0.7f</span><span class="p">;</span>		<span class="c1">// 调整音量
</span><span class="c1"></span>            <span class="n">tempS</span><span class="p">.</span><span class="n">Play</span><span class="p">();</span>				<span class="c1">// 播放
</span><span class="c1"></span>            <span class="n">tempAG</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AudioGroup</span><span class="p">(</span><span class="n">tempS</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
            <span class="n">audioSource_King</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">tempAG</span><span class="p">);</span>
            <span class="n">StartCoroutine</span><span class="p">(</span><span class="n">DeleteAudioAfterPlay</span><span class="p">(</span><span class="n">tempAG</span><span class="p">,</span> <span class="n">audioSource_King</span><span class="p">));</span>	<span class="c1">// 协程，具体见下
</span><span class="c1"></span>            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 等待音效播放完后自动卸载 */</span>
<span class="n">IEnumerator</span> <span class="n">DeleteAudioAfterPlay</span><span class="p">(</span><span class="n">AudioGroup</span> <span class="n">ag</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">AudioGroup</span><span class="p">&gt;</span> <span class="n">agList</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="n">WaitForSeconds</span><span class="p">(</span><span class="n">ag</span><span class="p">.</span><span class="n">audioSource</span><span class="p">.</span><span class="n">clip</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>	<span class="c1">// length获取音频长度，WaitForSeconds(等待时间)
</span><span class="c1"></span>    <span class="n">agList</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="n">ag</span><span class="p">);</span>
    <span class="n">Destroy</span><span class="p">(</span><span class="n">ag</span><span class="p">.</span><span class="n">audioSource</span><span class="p">);</span>	<span class="c1">// 卸载组件
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>等等，这里是不是出现了什么奇怪的东西？AudioGroup是什么？</p>
<p>这是我自己定义的一个类（<em>不太喜欢用结构</em>），主要考虑到这样的情况：有多个敌人开着音响，而根据已有的内容无法将敌人与音效一一对应（因为都绑定在AudioManager的物体上）。具体内容见下：（之后有需要，我们也可以扩充这个类的变量）</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="cm">/* 在AudioManager类之外 */</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">AudioGroup</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">AudioSource</span> <span class="n">audioSource</span><span class="p">;</span>		<span class="c1">// 音响
</span><span class="c1"></span>    <span class="k">public</span> <span class="n">GameObject</span> <span class="n">target</span><span class="p">;</span>			<span class="c1">// 对应的物体
</span><span class="c1"></span>    
    <span class="cm">/* 构造函数，用于赋值 */</span>
    <span class="k">public</span> <span class="n">AudioGroup</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">AudioGroup</span><span class="p">(</span><span class="n">AudioSource</span> <span class="n">audioS</span><span class="p">,</span> <span class="n">GameObject</span> <span class="n">t</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">audioSource</span> <span class="p">=</span> <span class="n">audioS</span><span class="p">;</span>
        <span class="n">target</span> <span class="p">=</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>最后，我们只要在合适的地方按这个万能按钮就行了~至于怎么调用，就看你们自己的想法了，写在对应执行的地方或者作为事件放在动画里都是可以的。</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="cm">/* 在AudioManager类之外，额外写个函数是方便作为事件放在动画里。 */</span>
<span class="k">void</span> <span class="n">RunAudio</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">AudioManager</span><span class="p">.</span><span class="n">instance</span><span class="p">.</span><span class="n">PlayMusic</span><span class="p">(</span><span class="n">MusicType</span><span class="p">.</span><span class="n">Run_King</span><span class="p">,</span> <span class="n">gameObject</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>当然，这种管理方式不仅限于音频管理，各位大可修改后用作其他方式的处理。</p>
<h2 id="后记">后记</h2>
<p>这种全局管理的结构，个人相信应该不是最优解，也许在之后学习了更多知识后，会有进一步的优化。这篇文章，就当是提供一种思路吧。另外，我在学习本文相关内容时，借鉴了不少帖子、视频，包括但不限于：</p>
<p><a href="https://www.bilibili.com/video/BV17E411Y7VN">Unity 2D教程:从独立游戏学习开发12: 音效控制(Audio Manager)——M_Studio</a></p>
]]></content>
		</item>
		
		<item>
			<title>输入缓冲与土狼时间的实现|Unity2D学习日记（一）</title>
			<link>https://ironhao-github-io.pages.dev/posts/%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E4%B8%8E%E5%9C%9F%E7%8B%BC%E6%97%B6%E9%97%B4/</link>
			<pubDate>Mon, 13 Sep 2021 22:16:40 +0800</pubDate>
			
			<guid>https://ironhao-github-io.pages.dev/posts/%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E4%B8%8E%E5%9C%9F%E7%8B%BC%E6%97%B6%E9%97%B4/</guid>
			<description>引言 个人学习积累中，如有任何问题与错误，欢迎指出与讨论。 这系列将会记录我在搭建自己的2D平台游戏时遇到的一些问题与解决方案，核心目的均为更好</description>
			<content type="html"><![CDATA[<h2 id="引言">引言</h2>
<blockquote>
<p>个人学习积累中，如有任何问题与错误，欢迎指出与讨论。</p>
</blockquote>
<p>这系列将会记录我在搭建自己的2D平台游戏时遇到的一些问题与解决方案，核心目的均为<strong>更好的游戏体验与更棒的代码逻辑结构</strong>。<em>所有代码基于C#与Unity。</em></p>
<h2 id="正文">正文</h2>
<blockquote>
<p>跳跃的手感能衡量一个2D平台游戏的好坏。——鲁迅</p>
</blockquote>
<p>不知道你是处理玩家跳跃的判断条件的？反正就我而言，射线或者子物体检测地面图层：如果角色在地面上，则允许跳跃；反之则不允许。</p>
<p>但是这样在游玩的时候会导致一个问题：当你想要连跳时，单按跳跃键，你以为自己已经落到了地面，而实际上，你还在空中，从而造成了“<strong>按键失灵</strong>”的问题。这对于玩家的游玩体验有着相当大的影响。</p>
<p>而解决这个问题的方法，就是<strong>允许指令的预输入，在预输入后的一段时间内，若检测到条件满足，再执行操作——即“输入缓冲”。</strong></p>
<p>不过，在介绍输入缓冲的方法前，我们先来了解一下计时器。</p>
<h3 id="计时器">计时器</h3>
<p>计时器，顾名思义，是为了计算一段时间，当计时器到达设定条件后，会执行相应的操作。</p>
<p>Unity提供了一个类似的方法，<code>Invoke(&quot;方法名（无参）, 延迟时间&quot;)</code>或者<code>InvokeRepeating(&quot;方法名（无参）, 延迟时间, 间隔时间&quot;)</code>用于重复调用。但是限制较多，且不适用于我们的输入缓冲：它只能做到延迟调用，而不能在延迟的这段时间内一满足条件就调用。</p>
<p>另外还可以在协程中使用<code>yield return new WaitForSeconds(具体秒数);</code>等方法实现。同样的问题是，它也只能实现延迟调用。</p>
<p>那么，我们到底该怎么定义一个可用于输入缓冲的计时器呢？以下是个人常用的一种写法。</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="c1">// 所用变量
</span><span class="c1"></span><span class="k">private</span> <span class="kt">float</span> <span class="n">timer</span><span class="p">;</span>           <span class="c1">// 计时器
</span><span class="c1"></span><span class="k">private</span> <span class="kt">float</span> <span class="n">timer_max</span> <span class="p">=</span> <span class="m">2f</span><span class="p">;</span>       <span class="c1">// 限定时间
</span><span class="c1"></span>
<span class="c1">// 初始化，一般在按下按键时执行，实现预输入
</span><span class="c1"></span><span class="n">timer</span> <span class="p">=</span> <span class="n">timer_max</span><span class="p">;</span>

<span class="c1">// 计时过程，一般放在Update里，每帧调用
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">timer</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">timer</span> <span class="p">-=</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">timer</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">timer</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="cm">/* 计时器到点结束执行的内容，超出限定时间，类似于延迟执行的部分 */</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="cm">/* 计时器还在计算时的内容，在限定时间内，输入缓冲就可以放在这 */</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>主要思路就是利用<code>Time.deltaTime</code>来计算并减去时间，关于增量时间，<a href="https://blog.csdn.net/ChinarCSDN/article/details/82914420">这里有一篇不错的文章</a>，就不再赘述。</p>
<p>那么，接下来，利用这个计时器，实现“输入缓冲”效果吧。</p>
<h3 id="输入缓冲">输入缓冲</h3>
<p>让我们再明确下，<strong>我们想要随时能够输入跳跃指令，并让这个指令在内存中保存一定时间，在该段时间内只要满足条件（接触地面）就执行跳跃指令</strong>。以下是两种执行写法（第一种为我游戏中使用 / 第二种为在上方计时器模板上进行修改）:</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="cm">/* 所用变量 */</span>
<span class="k">private</span> <span class="kt">float</span> <span class="n">buffer_jump_counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>    	<span class="c1">// 跳跃输入缓冲计数器
</span><span class="c1"></span><span class="k">private</span> <span class="kt">float</span> <span class="n">buffer_jump_max</span> <span class="p">=</span> <span class="m">0.1f</span><span class="p">;</span>     	<span class="c1">// 跳跃输入缓冲最大值
</span><span class="c1"></span><span class="k">private</span> <span class="kt">bool</span> <span class="n">hasJumpForce</span><span class="p">;</span>            		<span class="c1">// 此时是否拥有跳跃力了，避免重复给跳跃力,该力会在接触地面后自动重置为false
</span><span class="c1"></span>
<span class="cm">/* 输入指令，Update()中 */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="n">GetButtonDown</span><span class="p">(</span><span class="s">&#34;Jump&#34;</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">buffer_jump_counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 计时器与执行指令，Update()中 */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">buffer_jump_counter</span> <span class="p">&lt;</span> <span class="n">buffer_jump_max</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">buffer_jump_counter</span> <span class="p">+=</span> <span class="p">(</span><span class="m">1</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IsOnGround</span><span class="p">()</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">hasJumpForce</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">hasJumpForce</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">AddForce</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">jumpForce</span><span class="p">),</span> <span class="n">ForceMode2D</span><span class="p">.</span><span class="n">Impulse</span><span class="p">);</span>	<span class="c1">//具体施加跳跃力操作
</span><span class="c1"></span>        <span class="n">Debug</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="s">&#34;输入缓冲，启动一次！&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>下面这种我未在游戏中测试过，不保证正确性。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="cm">/* 所用变量一致，不再赘述 */</span>

<span class="cm">/* 输入指令，Update()中 */</span>
<span class="n">buffer_jump_counter</span> <span class="p">=</span> <span class="n">buffer_jump_max</span><span class="p">;</span>

<span class="cm">/* 计时器与执行指令，Update()中 */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">buffer_jump_counter</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">buffer_jump_counter</span> <span class="p">-=</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buffer_jump_counter</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">buffer_jump_counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="cm">/* 计时器到点结束执行的内容，超出限定时间，类似于延迟执行的部分 */</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="cm">/* 计时器还在计算时的内容，在限定时间内，输入缓冲就可以放在这 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">IsOnGround</span><span class="p">()</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">hasJumpForce</span><span class="p">)</span>
    	<span class="p">{</span>
        	<span class="n">hasJumpForce</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        	<span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">AddForce</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">jumpForce</span><span class="p">),</span> <span class="n">ForceMode2D</span><span class="p">.</span><span class="n">Impulse</span><span class="p">);</span>	<span class="c1">//具体施加跳跃力操作
</span><span class="c1"></span>        	<span class="n">Debug</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="s">&#34;输入缓冲，启动一次！&#34;</span><span class="p">);</span>
    	<span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这样，我们就实现了输入缓冲的效果。输入缓冲还可以用在很多的地方，如游戏中在空中连续多次按下↓方向键实现砸击地面的效果&hellip;&hellip;更多的用法，就留待各位自行尝试了。</p>
<p>除此之外，跳跃的输入缓冲还有一个好兄弟，“土狼时间”。</p>
<h3 id="土狼时间">土狼时间</h3>
<p>土狼时间，就是让玩家所操控的人物，能够在离开平台的一段时间内，仍能执行起跳操作。它的目的，也是优化操作，减少“操作失灵”的现象。那么，我们是不是也可以用个计时器，来实现呢？可以自己先想一想。</p>
<p>怎么样，有思路了吗？</p>
<p><strong>我们只要把计时器启动的时间改为离开地面即可，当我们离开地面，又没有执行过跳跃，就可以在一定的时间内，执行跳跃指令</strong>。以下是两种执行方法（同样，第一种为我游戏中使用 / 第二种修改自计时器模板）：</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="cm">/* 所用变量 */</span>
<span class="k">private</span> <span class="kt">float</span> <span class="n">buffer_coyote_counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>    <span class="c1">// 跳跃土狼时间计数器
</span><span class="c1"></span><span class="k">private</span> <span class="kt">float</span> <span class="n">buffer_coyote_max</span> <span class="p">=</span> <span class="m">0.1f</span><span class="p">;</span>       <span class="c1">// 跳跃土狼时间最大值
</span><span class="c1"></span><span class="k">private</span> <span class="kt">bool</span> <span class="n">hasJumpForce</span><span class="p">;</span>              <span class="c1">// 此时是否拥有跳跃力了，避免重复给跳跃力
</span><span class="c1"></span>
<span class="cm">/* 初始化，在Start()中 */</span>
<span class="n">buffer_coyote_counter</span> <span class="p">=</span> <span class="n">buffer_coyote_max</span><span class="p">;</span>

<span class="cm">/* 更新指令，该函数在Update()中调用 */</span>
<span class="k">void</span> <span class="n">CheckForJump</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IsOnGround</span><span class="p">()</span> <span class="p">&amp;&amp;</span> <span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">velocity</span><span class="p">.</span><span class="n">y</span> <span class="p">&lt;</span> <span class="m">0.05f</span> <span class="p">&amp;&amp;</span> <span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">velocity</span><span class="p">.</span><span class="n">y</span> <span class="p">&gt;</span> <span class="p">-</span><span class="m">0.05f</span><span class="p">)</span>
	<span class="p">{</span>
        <span class="n">hasJumpForce</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="n">buffer_coyote_counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 计时器与执行指令，Update()中 */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">buffer_coyote_counter</span> <span class="p">&lt;</span> <span class="n">buffer_coyote_max</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">hasJumpForce</span> <span class="p">&amp;&amp;</span> <span class="n">Input</span><span class="p">.</span><span class="n">GetButtonDown</span><span class="p">(</span><span class="s">&#34;Jump&#34;</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">hasJumpForce</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">buffer_coyote_counter</span> <span class="p">=</span> <span class="n">buffer_coyote_max</span><span class="p">;</span>
        <span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">AddForce</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">jumpForce</span><span class="p">),</span> <span class="n">ForceMode2D</span><span class="p">.</span><span class="n">Impulse</span><span class="p">);</span>
        <span class="n">Debug</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="s">&#34;土狼时间，启动一次！&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">buffer_coyote_counter</span> <span class="p">&lt;</span> <span class="n">buffer_coyote_max</span><span class="p">)</span>
    <span class="n">buffer_coyote_counter</span> <span class="p">+=</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">;</span>
</code></pre></div><blockquote>
<p>下面这种我未在游戏中测试过，不保证正确性 * 2。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="cm">/* 所用变量一致，不再赘述 */</span>

<span class="cm">/* 更新指令，该函数在Update()中调用 */</span>
<span class="k">void</span> <span class="n">CheckForJump</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IsOnGround</span><span class="p">()</span> <span class="p">&amp;&amp;</span> <span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">velocity</span><span class="p">.</span><span class="n">y</span> <span class="p">&lt;</span> <span class="m">0.05f</span> <span class="p">&amp;&amp;</span> <span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">velocity</span><span class="p">.</span><span class="n">y</span> <span class="p">&gt;</span> <span class="p">-</span><span class="m">0.05f</span><span class="p">)</span>
	<span class="p">{</span>
        <span class="n">hasJumpForce</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="n">buffer_coyote_counter</span> <span class="p">=</span> <span class="n">buffer_coyote_max</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 计时器与执行指令，Update()中 */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">buffer_coyote_counter</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">buffer_coyote_counter</span> <span class="p">-=</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buffer_coyote_counter</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">buffer_coyote_counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="cm">/* 计时器到点结束执行的内容，超出限定时间，类似于延迟执行的部分 */</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="cm">/* 计时器还在计算时的内容，在限定时间内，输入缓冲就可以放在这 */</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">hasJumpForce</span> <span class="p">&amp;&amp;</span> <span class="n">Input</span><span class="p">.</span><span class="n">GetButtonDown</span><span class="p">(</span><span class="s">&#34;Jump&#34;</span><span class="p">))</span>
    	<span class="p">{</span>
        	<span class="n">hasJumpForce</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        	<span class="n">buffer_coyote_counter</span> <span class="p">=</span> <span class="n">buffer_coyote_max</span><span class="p">;</span>
        	<span class="n">rigidbody2D_Role</span><span class="p">.</span><span class="n">AddForce</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">jumpForce</span><span class="p">),</span> <span class="n">ForceMode2D</span><span class="p">.</span><span class="n">Impulse</span><span class="p">);</span>
        	<span class="n">Debug</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="s">&#34;土狼时间，启动一次！&#34;</span><span class="p">);</span>
    	<span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>怎么样？这样就完美了吧。</p>
<p>其实关于游戏中的跳跃，还有很多的学问，例如<strong>如何合理高效的处理跳跃各个状态的动画（起跳、上升、最高点、下落、落地），跳跃中额外力的施加（如马里奥中的跳跃上升慢，下降快，并不只受到重力影响）&hellip;&hellip;</strong></p>
<p>其他的内容，就下次再说吧！</p>
<h2 id="后记">后记</h2>
<p>我在学习本文相关内容时，借鉴了不少帖子、视频，包括但不限于：</p>
<p><a href="https://indienova.com/indie-game-development/2d-platformer-input-buffering-design/">译文｜Gamemaker Studio系列：2D 平台游戏的输入缓冲 ——highway★</a></p>
<p><a href="https://www.bilibili.com/video/BV1fX4y1G7tv">使用Unity实现动作游戏的打击感 —— <strong>奥飒姆_Awesome</strong></a></p>
]]></content>
		</item>
		
		<item>
			<title>使用Polybrush更快更方便地搭建场景|Unity3D学习日记（二）</title>
			<link>https://ironhao-github-io.pages.dev/posts/unity%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%BA%8C/</link>
			<pubDate>Fri, 06 Aug 2021 22:52:37 +0800</pubDate>
			
			<guid>https://ironhao-github-io.pages.dev/posts/unity%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%BA%8C/</guid>
			<description>前言 本文为学习Unity途中的日常学习记录，主要是给自己的归纳总结，如有错误，还请指正。教程参考麦扣 @M_Studio的 3D RPG 核心教程。 正文 安</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本文为学习Unity途中的日常学习记录，主要是给自己的归纳总结，如有错误，还请指正。<em><strong>教程参考麦扣 @M_Studio的 3D RPG 核心教程。</strong></em></p>
<h2 id="正文">正文</h2>
<h3 id="安装polybrush">安装Polybrush</h3>
<p>同样通过点击 <code>Window -&gt; Package Manager</code> 并选择Unity Registry，找到Polybrush进行安装。注意，除了上述常规操作外，还需要单击<code>Samples</code>导入对应的Shader，如我们这使用URP，就需要导入第二个，如图所示。</p>
<p><img src="https://i.loli.net/2021/08/06/QOzM3gmZXayKnVs.png" style="zoom:67%;" /></p>
<h3 id="使用polybrush">使用Polybrush</h3>
<p>通过点击右上角的<code>Tools -&gt; Polybrush -&gt; Polybrush Window </code>来打开窗体。</p>
<p><img src="https://i.loli.net/2021/08/06/MtzAOgSBKTer4pI.png" style="zoom: 50%;" /></p>
<p>这里，<strong>从左往右</strong>的功能分别是：调整地面的高矮等状态；柔化效果；将当前的物体刷上不同的颜色；将预制体刷到场景中；将Texture刷到当前场景中。</p>
<p>另外，<code>Outer Radius</code>是外圈的大小，<code>Inner Radius</code>是内圈的大小，<code>Strength</code>是设置强度。</p>
<p><code>Brush Mirroring</code> 可以选择镜像的方向，从而刷出对称的图形。可以同时选择一个或多个轴，如我这里选择了X和Z轴。</p>
<p><img src="https://i.loli.net/2021/08/06/qkM4wpmXDNhoVA6.png" style="zoom:67%;" /></p>
<h4 id="调整地面高矮">调整地面高矮</h4>
<p>首先选中我们要进行修改的物体（这里是地面）并将Polybrush切换到第一个模式。此时地面会出现许多这样的三角形，每个点都是可以修改的。圆环是我们刷子的范围，<strong>可以通过触控板的放大缩小手势修改大小</strong>。</p>
<p><img src="https://i.loli.net/2021/08/06/e2iNcvX38sgR4Hu.png" alt=""></p>
<p><strong>鼠标点击拖拽</strong>可以向上拉升（或者双击也行，一次会升高一点）</p>
<p><img src="https://i.loli.net/2021/08/06/yj2que3cI6GC5wm.png" style="zoom:67%;" /></p>
<p><strong>按住Ctrl键</strong>会发现圆心向上的射线变成向下的了，此时再<strong>点击拖拽</strong>就可以向下挤压。</p>
<p><img src="https://i.loli.net/2021/08/06/fDLE9pnC1d2QYVi.png" alt=""></p>
<h4 id="柔化效果">柔化效果</h4>
<p><strong>选择模式二，鼠标点击拖拽即可</strong>，方法和调整地面高矮类似。个人感觉有点像模式一的撤销操作，对凸处执行会让棱角往里收，对凹处执行则会让凹陷处往回收。可以自行尝试下。</p>
<h4 id="将当前的物体刷上不同的颜色">将当前的物体刷上不同的颜色</h4>
<p><strong>选择模式三。<strong>另外，还要</strong>修改材质</strong>。找到并选中我们之前导入的文件夹中的<code>Lit Vertex Color URP </code>文件，右键<code>Create -&gt; Material</code>,Unity会为我们自动创建生成相应的材质。之后我们直接将材质拖拽到场景对应的物体（这里是地面）上去即可。</p>
<p><img src="https://i.loli.net/2021/08/06/YZpFLIlgf6M1KeB.png" style="zoom: 67%;" /></p>
<p>然后我们就可以尽情的刷颜色啦。<strong>这个的用处主要是初期场景原型搭建时用于区分各个区域，方便后续的操作。</strong></p>
<p><img src="https://i.loli.net/2021/08/06/oNYCR3AqSMrEWTP.png" style="zoom:67%;" /></p>
<p>另外，这里有三个功能选项，分别是</p>
<ul>
<li><code>Brush</code>像喷漆一样喷上颜色，同一块颜色可以越喷越深，不同颜色也可以相互影响。</li>
<li><code>Fill</code>根据三角来填充，填充上去就是最深的颜色了，会覆盖底层的颜色。</li>
<li><code>Flood</code>将整个物体刷成某个颜色</li>
</ul>
<h4 id="将预制体刷到场景中">将预制体刷到场景中</h4>
<p>选择模式四，并将需要的预制体选中并添加到<code>Current Palette</code>中。<strong>这里选中第一个，然后按住Shift并选中最后一个，就会把全部选中，此时如果有部分预制体是你不想选中的，再按住Ctrl并点击，点击的预制体就会被取消选中。</strong></p>
<p>再从调色板中将你想要刷的物体勾选上，就会显示在上方的<code>Brush Loadout</code>中，调节每个物体下方的按钮可以选择出现的概率。</p>
<p><img src="https://i.loli.net/2021/08/06/vrnFfkpqOB6txD3.png" style="zoom:50%;" /></p>
<p>然后在场景上点击就会生成啦！如果要删除，<strong>按住Ctrl再去点按生成的物体</strong>就行。由这种方法生成的树会有一圈蓝边，方便我们与其他的进行区分（同时我们也只能删除由这种方法生成的物体）。另外由于默认勾选了<code>Hit Surface is Parent</code>,所有生成的树的父类都是我们的选中的地面。</p>
<p><img src="https://i.loli.net/2021/08/06/ESgq2fGOjLDK3Vv.png" style="zoom:50%;" /></p>
<p>另外生成的时候有些物体并没有完全与地面贴合，这时候就需要我们自己手动调整了（可使用V键快速吸附！参考上一节的内容）。</p>
<h2 id="后记">后记</h2>
<p>Polybrush还是非常方便好用的，感觉要是能够结合代码，自动生成，就可以创建随机地图了。这块有空可以再研究研究！</p>
]]></content>
		</item>
		
		<item>
			<title>Unity3D导入素材与搭建场景|Unity3D学习日记（一）</title>
			<link>https://ironhao-github-io.pages.dev/posts/unity%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B8%80/</link>
			<pubDate>Thu, 05 Aug 2021 21:36:27 +0800</pubDate>
			
			<guid>https://ironhao-github-io.pages.dev/posts/unity%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B8%80/</guid>
			<description>前言 本文为学习Unity途中的日常学习记录，主要是给自己的归纳总结，如有错误，还请指正。教程参考麦扣 @M_Studio的 3D RPG 核心教程。 正文 从</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本文为学习Unity途中的日常学习记录，主要是给自己的归纳总结，如有错误，还请指正。<em><strong>教程参考麦扣 @M_Studio的 3D RPG 核心教程。</strong></em></p>
<h2 id="正文">正文</h2>
<h4 id="从商店导入所需内容">从商店导入所需内容</h4>
<p>点击左上角的 Window -&gt; Package Manager 打开对应窗体</p>
<p><img src="https://i.loli.net/2021/08/04/beJkMYX7GSH2oIa.png" alt=""></p>
<p>在新打开的窗体中的左上角，可以选择范围。</p>
<ul>
<li>一些从Unity商店中购买的素材可以在 My Assets 里找到，如果购买了而没有显示，请点击下方中间的刷新按钮，刷新一下即可</li>
<li>而如 Universal RP 等Unity提供的功能则可在 Unity Registry 里找到</li>
</ul>
<p><img src="https://i.loli.net/2021/08/04/CpOqrWzfUI73VDY.png" alt=""></p>
<p>找到对应内容后，点击右下角 Install 安装即可</p>
<h4 id="创建渲染管线">创建渲染管线</h4>
<p>右键 Assets，选择如下图的操作，点击确认，生成。</p>
<p><img src="https://i.loli.net/2021/08/04/HOPfpWGi6twNLdy.png" alt=""></p>
<p>再在右上角的 Edit -&gt; Project Setting 里找到 Graphics，设置相应的通用管线</p>
<p><img src="https://i.loli.net/2021/08/04/bNEXFxaVLHkURSf.png" alt=""></p>
<p>在Quality里的Rendering里进行同样的操作，设置通用管线</p>
<p>在导入支持URP的素材后，可以点击右上角的 Edit 按钮，执行如下操作 。其中第一个是更新全部，第二个是只更新选中的部分</p>
<p><img src="https://i.loli.net/2021/08/04/R3asLczug6vyCWm.png" alt=""></p>
<h4 id="修改通用渲染管线设置以调整阴影等">修改通用渲染管线设置以调整阴影等</h4>
<p>找到我们之前创建的通用渲染管线的Asset，单击，右边的Inspector里就会显示一些可供修改的参数。包括品质、阴影、抗锯齿等。</p>
<p>Shadows栏中，Max Distance指出最远的阴影渲染距离，超过后不再渲染，Cascade Count指出将阴影分几个层级，达到越远越虚，不同距离阴影渲染级别不同等效果。Soft Shadows勾选后阴影会变得更加柔和。</p>
<h4 id="取消显示天空盒子和替换天空盒子">取消显示天空盒子和替换天空盒子</h4>
<p>选中Scene场景，然后根据如下图所示操作取消Skybox即可。</p>
<p><img src="https://i.loli.net/2021/08/04/B5vP9a6yM3Gg4ck.png" alt=""></p>
<p>替换天空盒子的话，可以在Unity商店里找到相应的素材并导入，记得更新全部URP素材，这样素材才能正常显示。然后找到左上角的 Window 菜单，按下图所示操作，并在打开的文件夹中选择 Environment ,其中的 Skybox Matertial 就是我们可以替换的部分了</p>
<p><img src="https://i.loli.net/2021/08/04/2j6zM1yBVwxvCuN.png" alt=""></p>
<p>另外，你选择的天空盒子的Inspector中有一些参数可以修改，这里不再说明。</p>
<p>如果发现场景光颜色变得不一样，那是因为默认环境光跟随天空盒子颜色的变化而变化，我们可以在Lighting的Environment栏的Environment Lighting里进行修改。Source可以修改光来源。其中对于Skybox而言，Intensity Multiplier可以控制光受天空盒子影响的强弱。</p>
<p><img src="https://i.loli.net/2021/08/04/nzZLkig6cNS2pMA.png" alt=""></p>
<h4 id="光照设置">光照设置</h4>
<p>同样在之前设置天空盒子的Lighting里，不过是在Scene栏，我们选择 New Lighting Settings 选项，Unity会为我们自动创建。然后在Lighting的Scene栏中，选择Generate Lighting，Unity就会为我们渲染光线。<strong>注意，GPU显存较少等情况无法使用GPU进行渲染。</strong></p>
<h4 id="场景搭建小技巧">场景搭建小技巧</h4>
<ul>
<li><strong>V键为顶点自动吸附</strong>，按住V键进行方块的搭建，可以快速吸附到另一个物体（如地面）上，不需要列文虎克式微调了。具体用法，<strong>选中你想要移动的物体→按住v键，确定你要对的顶点→然后双击鼠标左键移动</strong>。</li>
<li>Prefab建议拖拽到场景栏中，而不是直接拖拽到场景中，这样会保持为（0，0，0）坐标，方便查找和后续的移动。</li>
<li>使用空的物体来作为父物体并命名，将场景中的物体拖拽到该物体上，作为它的子物体，来实现对场景中的各类物体的分类。（操作流程： 场景栏右键-&gt; Create Empty）</li>
<li>还可以使用空物体并命名，作为分隔栏使用，来区分。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>了解Big-Oh notation,以及算法的抉择</title>
			<link>https://ironhao-github-io.pages.dev/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%8A%89%E6%8B%A9/</link>
			<pubDate>Wed, 24 Mar 2021 19:45:07 +0800</pubDate>
			
			<guid>https://ironhao-github-io.pages.dev/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E6%8A%89%E6%8B%A9/</guid>
			<description>虽然跟着老师已经将数据结构了解了大半，但是对于O(N)的判断还是不太清楚，于是花了一个晚上的时间把书本第二章关于算法的问题又看了看，稍微写点</description>
			<content type="html"><![CDATA[<p>  虽然跟着老师已经将数据结构了解了大半，但是对于O(N)的判断还是不太清楚，于是花了一个晚上的时间把书本第二章关于算法的问题又看了看，稍微写点总结和感悟。</p>
<h2 id="big-oh-notation">Big-Oh notation</h2>
<p>  也就是我们通常所说的O(N)，它表示了一个程序的算法复杂度，一般我们说的都是时间复杂度，即需要多少时间。有以下几种常见的类型：</p>
<p><img src="https://i.loli.net/2021/03/24/LV4Cip6O3QEASsG.png" alt=""></p>
<blockquote>
<p>When we say that T(N) = O(f(N)), we are guaranteeing that the function T(N)grows at a rate no faster than f(N); thus f(N )is an upper bound on T(N).</p>
</blockquote>
<p>  就像书本说的，默认考虑的都是最坏情况，因为这才能更好的反映一个算法的好坏，保证程序在各种极端条件下的稳定性。最准确具体的O(N)算法是将加减乘除以及赋值等基础操作所花的时间当作一个单元，逐行分析计算结果，但这明显不太现实。所以我们有几个优化的小规则(个人理解版~)：</p>
<ul>
<li>对于循环，循坏几次，就是几次，比如<code>for(int i = 0; i &lt; n; i++)</code>这就是O(N)；内嵌循环也是，比如内部循环N次，外部N次，那就是O(N²)</li>
<li>忽略常数，N+6次和N+1次的区别在N趋于无穷大时可以忽略不急</li>
<li>if条件判断中，选择几个分支中O(N)最大的那个</li>
<li>如果有递归的话，从base case开始试，一步步往上累加，从中找到规律</li>
</ul>
<h2 id="算法的抉择">算法的抉择</h2>
<p>  书本后面又讲解使用了四种不同的算法去解决‘最大字串’(Maximum Subsequence Sum Problem)的问题：从暴力枚举到巧用递归再到发现利用问题的细节。时间复杂度逐步下降，但同时创造、验证算法正确性的难度也逐步提升。求快与求稳，是一个难以平衡的事情。在这个问题中，我们还可以较容易的检验每个算法（即使是最后一个）的正确与否，但是程序更复杂后就难以实现了。</p>
<p>  权衡利弊，需要靠我进一步的学习了。</p>
]]></content>
		</item>
		
		<item>
			<title>通过Single/Double Rotation来确保AVL Tree的成立|学习记录</title>
			<link>https://ironhao-github-io.pages.dev/posts/avl%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC/</link>
			<pubDate>Tue, 23 Mar 2021 18:33:32 +0800</pubDate>
			
			<guid>https://ironhao-github-io.pages.dev/posts/avl%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC/</guid>
			<description>AVL树拥有O(logN)的查找和删除速度，这也是我们创建这种数据结构的原因，但是，一次删除或者添加操作就可能破坏其脆弱的结构，因此我们需要</description>
			<content type="html"><![CDATA[<p>  AVL树拥有O(logN)的查找和删除速度，这也是我们创建这种数据结构的原因，但是，一次删除或者添加操作就可能破坏其脆弱的结构，因此我们需要Single/Double Rotation来保证其结构的正确。</p>
<h2 id="什么是avl树">什么是AVL树</h2>
<blockquote>
<p>AVL tree is binary search tree with self balancing ability.</p>
<p>Its height difference between the right and left subtree of all nodes not greater than one.</p>
</blockquote>
<p>  简单来说，就是一个每个叶子的高度差不大于一的二叉搜索树。</p>
<h2 id="sd-rotation">S/D Rotation</h2>
<h4 id="为什么需要">为什么需要</h4>
<p><img src="https://i.loli.net/2021/03/23/UIB7ct5MvCQbRd3.png" alt=""></p>
<p>  如图所示，一次简单的插入操作后，200右边的高度变成了4，而左边为2，叶子的高度差大于1，直接破坏了AVL树的结构。通过Single/Double Rotation，我们可以恢复其结构。</p>
<h4 id="使用时机与选择">使用时机与选择</h4>
<blockquote>
<p>这边有一个平衡系数用来判断其高度差。</p>
<p>即 左子树的高度 - 右子树的高度 = 该节点的平衡系数</p>
</blockquote>
<p>  简单来说，就是找，找到某个节点，其左右子树高度差大于二，那么此时就需要旋转了。一般来说，会有这么四种情况：</p>
<ul>
<li>左边子树的左节点过长（Left – Left Rotation）</li>
<li>右边子树的右节点过长（Right – Right Rotation）</li>
<li>右边子树的左节点过长（Right – Left Rotation）</li>
<li>左边子树的右节点过长（Left – Right Rotation)</li>
</ul>
<p>  前两种情况使用Single Rotation即可解决，后两种情况较为复杂，需要使用Double Rotation来解决。</p>
<h4 id="single-rotation">Single Rotation</h4>
<p>  上图就是一个R-R Rotation，即右子树的右节点过长。正常来说，我们需要按照以下步骤：</p>
<p><img src="https://i.loli.net/2021/03/23/WPJlkpsrtBzEdvM.jpg" alt=""></p>
<ol>
<li>找到不平衡的点，即其平衡系数绝对值大于1(注意，这个点可能有好多个，应该选择层数最高的那个)</li>
<li>如图标红的线就是我们要移动的，我们将200绕着400逆时针旋转，把350挤掉（350与400的连线断开），使200成为400的左节点</li>
<li>将350作为200的右节点连接起来</li>
<li>完成</li>
</ol>
<p>  一个印象可能不够深刻，下图可以当一个练习。</p>
<p><img src="https://i.loli.net/2021/03/23/CJnaNqoWK9fD23i.png" alt=""></p>
<h4 id="double-rotation">Double Rotation</h4>
<p>  我们可以简单粗暴的理解成两次Single Rotation，以下是我们的操作流程:</p>
<p><img src="https://i.loli.net/2021/03/23/l5XAFpmSI4nMRdr.png" alt=""></p>
<ol>
<li>
<p>同样的，找到不平衡的点，这里4，6都是，我们应该选择6</p>
</li>
<li>
<p>两条虚线就是我们要移动的线，我们首先移动下面一条(即7和15连着的线)，我们将15绕着7顺时针旋转，挤掉14，再将14拼接在15上，结果如图所示(仅展示移动部分)</p>
<p><img src="https://i.loli.net/2021/03/23/Osy4dgIDmoBEpPH.png" alt=""></p>
</li>
<li>
<p>同样的操作，移动6和15连着的线，将6绕着7逆时针旋转(这时候没有需要挤掉的数)，将其变为7的左节点，结束</p>
</li>
</ol>
<h2 id="小结">小结</h2>
<p>  这块内容上课时没听清楚，花了挺久的时间才整明白，感觉网上的资料写的不是特别详细，只有开始与结果图，没有过程讲解，所以我就来写一写，既强化下记忆，也能帮助有需要的人~</p>
<p><em>网上参考资料:</em> <a href="https://www.guru99.com/avl-tree.html">https://www.guru99.com/avl-tree.html</a></p>
]]></content>
		</item>
		
		<item>
			<title>构造D-Heap并理解其插入删除算法|学习记录</title>
			<link>https://ironhao-github-io.pages.dev/posts/d-heap/</link>
			<pubDate>Fri, 19 Mar 2021 17:14:50 +0800</pubDate>
			
			<guid>https://ironhao-github-io.pages.dev/posts/d-heap/</guid>
			<description>这几周在痛苦的学习数据结构，老师给我们布置了一个构造D-Heap的作业，断断续续debug了两天，总算是实现了。这里就记录一下我的思路与过程</description>
			<content type="html"><![CDATA[<p>  这几周在痛苦的学习数据结构，老师给我们布置了一个构造D-Heap的作业，断断续续debug了两天，总算是实现了。这里就记录一下我的思路与过程。</p>
<h2 id="什么是d-heap">什么是D-Heap？</h2>
<blockquote>
<p>以下为个人目前见解，还在学习中，不一定完全正确。</p>
</blockquote>
<p>  首先，它是一个堆（heap）结构，我们常说的堆结构Binary-heap（这里以最小堆为例）应该满足以下两点：</p>
<ul>
<li>是一个完全二叉树（这样才能够存储在数组里）</li>
<li>每个父节点都要小于其子节点（最大堆相反）</li>
</ul>
<p>  而D-Heap可以理解为其变式，或者称为泛型，它的每个父节点可以拥有D个子节点。</p>
<h2 id="构造d-heap">构造D-Heap</h2>
<p>  Heap是存放在数组中的，通过简单的画格子方法，我们可以找到一个规律（假设我们从下标为0开始存数），<strong>第i位的数恰巧为第i * d 到第（i+1) * d位数的父节点</strong>，这也是我们构造的关键。</p>
<h4 id="插入">插入</h4>
<p>  插入的思路如下：</p>
<ol>
<li>将插入的数据存放在队尾；</li>
<li>由队尾的叶子开始，与其父节点进行比较，若父大子小，则进行交换，即选较小值作为父节点（默认为最大堆）;</li>
<li>重复第2步骤，直至不再需要交换或者遍历到了根节点，表明堆已是有序的了。</li>
</ol>
<p>  而由子节点找父节点的方法就用到了我们上面的规律，第（i-1）/d位的节点即使第i位的父节点。</p>
<p><img src="https://i.loli.net/2021/03/19/hcCtAOoue1RUiND.png" alt=""><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<h4 id="删除">删除</h4>
<p>  与插入的思路恰好相反，由根节点开始操作：</p>
<ol>
<li>保存好第0位的数据（如果你要返回被删除的值话），将最后一位的数据存放至第0位，覆盖掉，再删除掉最后一位；</li>
<li>从根节点开始，找到其子节点（总共有d个）中的最小值，如果父大子小，则交换他们；</li>
<li>重复第2步骤，直到交换完最后一层或不再交换。</li>
</ol>
<p><img src="https://i.loli.net/2021/03/19/YwinmT2BAuXhN7F.png" alt=""><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<h4 id="具体代码实现">具体代码实现</h4>
<p>  这边d我设置为4（按照题目要求)，可以修改为一个变量d，在初始化的时候确定。同时为了便于代码的阅读，我将交换（swap）和查找子节点最小数（minInOneSubTree）整合为私有方法。另外又设置了min这个结构，里面存有最小值的大小，对应的下标，以及是否存在（exist，主要用来解决只有1个的极端条件）。代码本身肯定还不够精简，还不是最终版本，可以作为参考。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">quadHeap</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">quadHeap</span><span class="p">()</span>
        <span class="p">{</span>
             <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CAPACITY</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
             <span class="p">{</span>
                 <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
             <span class="p">}</span>
        <span class="p">}</span>

        <span class="o">~</span><span class="n">quadHeap</span><span class="p">()</span>
        <span class="p">{</span>

        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">T</span> <span class="n">element</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">data</span><span class="p">[</span><span class="n">currentSize</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">currentIndex</span> <span class="o">=</span> <span class="n">currentSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">notOrdered</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">notOrdered</span> <span class="o">&amp;&amp;</span> <span class="n">currentIndex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">notOrdered</span> <span class="o">=</span> <span class="n">swap</span><span class="p">(</span><span class="n">currentIndex</span><span class="p">);</span>
                <span class="n">currentIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">currentIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
            <span class="p">}</span> 
        <span class="p">}</span>
            

        <span class="n">T</span> <span class="nf">deleteMin</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">T</span> <span class="n">returnElement</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">T</span> <span class="n">lastElement</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">--</span><span class="n">currentSize</span><span class="p">];</span>
            <span class="n">data</span><span class="p">[</span><span class="n">currentSize</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">returnElement</span><span class="p">;</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastElement</span><span class="p">;</span>
            <span class="n">min</span> <span class="n">minOne</span><span class="p">;</span>
            <span class="n">minOne</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">minOne</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">minOne</span><span class="p">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">currentSize</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">minOne</span> <span class="o">=</span> <span class="n">minInOneSubTree</span><span class="p">(</span><span class="n">minOne</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">minOne</span><span class="p">.</span><span class="n">exist</span><span class="p">)</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">minOne</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">returnElement</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">print</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">currentSize</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="k">struct</span> <span class="nc">min</span>
        <span class="p">{</span>
            <span class="n">T</span> <span class="n">data</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">exist</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 
        <span class="p">};</span>
        
        <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">CAPACITY</span> <span class="o">=</span> <span class="mi">61</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">currentSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">data</span><span class="p">[</span><span class="n">CAPACITY</span><span class="p">];</span>

        <span class="kt">bool</span> <span class="nf">swap</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            

            <span class="kt">bool</span> <span class="n">isChanged</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">preIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
            <span class="n">T</span> <span class="n">temp</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">preIndex</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">isChanged</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">preIndex</span><span class="p">];</span>
                <span class="n">data</span><span class="p">[</span><span class="n">preIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
                <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">isChanged</span><span class="p">;</span>
        <span class="p">}</span>


        <span class="n">min</span> <span class="nf">minInOneSubTree</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">min</span> <span class="n">minOne</span><span class="p">;</span>
            <span class="n">minOne</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
            <span class="n">minOne</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">minOne</span><span class="p">.</span><span class="n">data</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">minOne</span><span class="p">.</span><span class="n">exist</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">minOne</span><span class="p">;</span>
            <span class="p">}</span>
           
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">minOne</span><span class="p">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="p">{</span>
                    <span class="n">minOne</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">minOne</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">minOne</span><span class="p">;</span>
        <span class="p">}</span>

<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">quadHeap</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">testHeap</span><span class="p">;</span>
   
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Test&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">testHeap</span><span class="p">.</span><span class="n">deleteMin</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">testHeap</span><span class="p">.</span><span class="n">deleteMin</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">testHeap</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">testHeap</span><span class="p">.</span><span class="n">deleteMin</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">testHeap</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">testHeap</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><h2 id="小结">小结</h2>
<p>  写出来没错就好，也算进步了一点~</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>图片来自Mark A. Weiss - Data Structures and Algorithm Analysis in C++-Pearson (2014) <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>图片来自Mark A. Weiss - Data Structures and Algorithm Analysis in C++-Pearson (2014) <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
		</item>
		
		<item>
			<title>约瑟夫环的两种设计——结构化设计与OOP | 学习记录</title>
			<link>https://ironhao-github-io.pages.dev/posts/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1/</link>
			<pubDate>Sun, 14 Mar 2021 20:42:34 +0800</pubDate>
			
			<guid>https://ironhao-github-io.pages.dev/posts/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1/</guid>
			<description>周末赶了一个关于程序设计的作业，题目让我们分别用结构化设计与基于面向对象的设计思路来完成约瑟夫环的问题，刚好顺便复习下链表，以下是一点过程记</description>
			<content type="html"><![CDATA[<p>  周末赶了一个关于程序设计的作业，题目让我们分别用结构化设计与基于面向对象的设计思路来完成约瑟夫环的问题，刚好顺便复习下链表，以下是一点过程记录。</p>
<h2 id="约瑟夫环的实现">约瑟夫环的实现</h2>
<h4 id="结构化设计">结构化设计</h4>
<p>  这一块网络上的资料也很多，我这里提供一种方法。总的思路就是使用累加器来记录报数，到指定人数后将对应的人“杀死”，一直循环直至剩下一人，返回存活人的号码。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">nrOfPeople</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>   <span class="c1">// 总人数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">nrOfDead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// 死亡人数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">M</span><span class="p">;</span>  <span class="c1">// 题目所指定的M，报数报到M即死亡
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 第index个人
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 当前报数
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">survival</span><span class="p">[</span><span class="n">nrOfPeople</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>  <span class="c1">// 记录第n个人是否死亡
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Input M &#34;</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">M</span><span class="p">;</span>

    <span class="c1">// 初始化，全部人一开始都活着
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nrOfPeople</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">survival</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 开始筛选
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Dead: &#34;</span><span class="p">;</span>
    <span class="k">do</span>
    <span class="p">{</span>
        <span class="n">index</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">nrOfPeople</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">survival</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">number</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="o">==</span> <span class="n">M</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
            <span class="n">survival</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="n">nrOfDead</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">nrOfDead</span> <span class="o">!=</span> <span class="n">nrOfPeople</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 筛选至只剩一人结束
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 输出幸存的人所处位置
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Left one: &#34;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="n">nrOfPeople</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">survival</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h4 id="基于面向对象oop">基于面向对象（OOP）</h4>
<p>  根据我目前对OOP的理解，就是将问题分为许多个小问题，再将其封装成类，一个类解决一个问题。在这个约瑟夫环问题中，我分了三类：</p>
<ul>
<li>整个约瑟夫环的过程（JosephusProblem）</li>
<li>约瑟夫环中的人（PeopleInJos）</li>
<li>报数器（Number)</li>
</ul>
<p>  和结构化设计解决约瑟夫环的思路类似，将不同的内容分类塞入这三类里。JosephusProblem中，我们要控制游戏的过程，所以相应的初始化，以及需要的变量，包括调用其他两个类的两个变量，总人数、死亡人数，以及一个指向队首的指针（因为我使用了循环链表来存储人）。PeopleInJos中，存放每个人所必须的信息，在这里只有两个，存活与否（isSurvival)和他对应的号码（index），当然，因为类要封装，都必须设置相应的方法来调用到这些私有变量。Number中很简单，就是累加，到点了就返回相应的提示并重置，这个我集成在同一个方法（bool out()）里了。以下是具体代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// JosephusProblemOOP.cpp:
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;JosephusProblem.cpp&#34;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>   
    <span class="n">JosephusProblem</span> <span class="n">j</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">41</span><span class="p">);</span>
    <span class="n">j</span><span class="p">.</span><span class="n">initializa</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">.</span><span class="n">start</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// JosephusProblem.cpp:
</span><span class="c1"></span><span class="cp">#pragma once
</span><span class="cp">#include</span> <span class="cpf">&#34;PeopleInJos.cpp&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;Number.cpp&#34;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">JosephusProblem</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">JosephusProblem</span><span class="p">()</span>
        <span class="p">{</span>

        <span class="p">}</span>

        <span class="n">JosephusProblem</span><span class="p">(</span><span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PeopleInJos</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">num</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Number</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">nrOfPeople</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">nrOfDead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">initializa</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">PeopleInJos</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nrOfPeople</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">temp</span><span class="o">-&gt;</span><span class="n">setNext</span><span class="p">(</span><span class="k">new</span> <span class="n">PeopleInJos</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">temp</span><span class="o">-&gt;</span><span class="n">setNext</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="nf">start</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">tempI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">currentP</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="k">do</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">currentP</span><span class="o">-&gt;</span><span class="n">survival</span><span class="p">())</span>
                <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">num</span><span class="o">-&gt;</span><span class="n">out</span><span class="p">())</span>
                    <span class="p">{</span>
                        <span class="n">currentP</span><span class="o">-&gt;</span><span class="n">kill</span><span class="p">();</span>
                        <span class="n">nrOfDead</span><span class="o">++</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">currentP</span> <span class="o">=</span> <span class="n">currentP</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">nrOfDead</span> <span class="o">!=</span> <span class="n">nrOfPeople</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            
            <span class="n">currentP</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nrOfPeople</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">currentP</span><span class="o">-&gt;</span><span class="n">survival</span><span class="p">())</span>
                <span class="p">{</span>
                    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">currentP</span> <span class="o">=</span> <span class="n">currentP</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span> 
        <span class="n">Number</span><span class="o">*</span> <span class="n">num</span><span class="p">;</span>
        <span class="n">PeopleInJos</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">PeopleInJos</span><span class="o">*</span> <span class="n">currentP</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nrOfPeople</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nrOfDead</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Number.cpp:
</span><span class="c1"></span><span class="cp">#pragma once
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Number</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Number</span><span class="p">()</span>
        <span class="p">{</span>

        <span class="p">}</span>
        
        <span class="n">Number</span><span class="p">(</span><span class="kt">int</span> <span class="n">M</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">currentN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">setM</span> <span class="o">=</span> <span class="n">M</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="nf">out</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">currentN</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">currentN</span> <span class="o">&gt;=</span> <span class="n">setM</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">currentN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">currentN</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">setM</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// PeopleInJos.cpp:
</span><span class="c1"></span><span class="cp"># pragma once
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">PeopleInJos</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">PeopleInJos</span><span class="p">()</span>
        <span class="p">{</span>

        <span class="p">}</span>

        <span class="n">PeopleInJos</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">isSurvival</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">PeopleInJos</span><span class="o">*</span> <span class="nf">getNext</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">setNext</span><span class="p">(</span><span class="n">PeopleInJos</span><span class="o">*</span> <span class="n">next</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="nf">survival</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">isSurvival</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">kill</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">isSurvival</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">PeopleInJos</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">isSurvival</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
<span class="p">};</span>

</code></pre></div><h2 id="一些想法">一些想法</h2>
<p>  毕竟是开学初，刚开始系统的学习OOP设计思路，也许上面的类划分不够细致，不过程序跑起来后，感觉还是不错的，代码个人看着也还是比较清晰的。当然基于OOP设计的程序还是有点问题的，使用了指针却没有手动内存释放，会导致内存泄漏等。这些就留待下次有空完成吧~</p>
]]></content>
		</item>
		
		<item>
			<title>完善博客的第一步</title>
			<link>https://ironhao-github-io.pages.dev/posts/%E5%AE%8C%E5%96%84%E5%8D%9A%E5%AE%A2/</link>
			<pubDate>Sat, 13 Mar 2021 15:55:59 +0800</pubDate>
			
			<guid>https://ironhao-github-io.pages.dev/posts/%E5%AE%8C%E5%96%84%E5%8D%9A%E5%AE%A2/</guid>
			<description>​ 趁着周末，把之前刚刚搭建好的博客完善下~大部分的内容主题已经满足了，剩下的就是部署到github page上了。 目标 部署到github pag</description>
			<content type="html"><![CDATA[<p>​		趁着周末，把之前刚刚搭建好的博客完善下~大部分的内容主题已经满足了，剩下的就是部署到github page上了。</p>
<h2 id="目标">目标</h2>
<ul>
<li>部署到github page上，实现对外开放</li>
<li>绑定域名</li>
<li>使用PicGo来实现快速上传图片至图床</li>
</ul>
<h2 id="过程">过程</h2>
<h4 id="部署">部署</h4>
<p>​		部署还是比较方便的，网上有很多教程，这里我讲讲我的方法：</p>
<ol>
<li>
<p>在github上创建一个新的仓库，命名为yourname.github.io；</p>
</li>
<li>
<p>鉴于github推出了自己的桌面程序（GitHub Desktop），我们可以直接使用这个程序来绑定仓库。在网页新创一个仓库后，github会提示你如</p>
<p>下图所示内容，我们选择“Set up in Desktop&quot;,就可以打开程序，然后选择路径为你的博客需要上传的部分。（如我用的hugo，就设置路径为&hellip;/public）</p>
<p>PS: 绑定时本地文件夹里必须为空</p>
<p><img src="https://i.loli.net/2021/03/13/pPiUaoxF7eZcfRq.png" alt=""></p>
</li>
<li>
<p>完成，一切正常的话，接下来你就可以输入网址 <a href="http://yourname.github.io/">http://yourname.github.io/</a> 访问你的博客了</p>
</li>
</ol>
<h4 id="绑定域名">绑定域名</h4>
<p>​		在仓库的setting里，找到关于Github Page的设置，如下图所示</p>
<p><img src="https://i.loli.net/2021/03/13/XqZUMOgKGtdy2ks.png" alt=""></p>
<p>​		在Custom domain里，输入你的域名，顺便开启强制HTTPS。</p>
<p>​		另一方面，在cmd里输入 ping yourname.github.io，找到对应的ip，在域名那边添加两条解析，如下图所示，一条CNAME指向github分给你的域名，另一条A指向对应的ip。</p>
<p><img src="https://i.loli.net/2021/03/13/YPibhprVyURIMc8.png" alt=""></p>
<p>​		到这里，域名绑定算是完成了。但是打开网页，发现证书无效，显示网页为“不安全”状态。这怎么能忍，于是我决定配置Cloudflare来使用HTTPS，具体流程官网会提供的，<a href="https://dash.cloudflare.com/sign-up">点我转至Cloudflare官网</a>。</p>
<p>​		其中最后需要修改下DNS服务器，像万网点击“管理” → “DNS修改”就能找到了。</p>
<h4 id="picgo绑定">PicGo绑定</h4>
<p>​		PicGo在Github上搜索后就可以找到对应的项目仓库，进行下载。</p>
<p>​		我使用的图床是SM.MS，注册后点击右上角“User”→“Dashboard”→“API Token”→“Generate Secret Token”生成需要的密钥，然后复制到picgo对应的位置即可。</p>
<h2 id="结尾">结尾</h2>
<p>​		过程有些曲折，不过解决了就好~</p>
<p>​		参考文章：https://zhuanlan.zhihu.com/p/37752930</p>
]]></content>
		</item>
		
		<item>
			<title>反反复复的日常</title>
			<link>https://ironhao-github-io.pages.dev/posts/firstday/</link>
			<pubDate>Fri, 12 Mar 2021 20:09:01 +0800</pubDate>
			
			<guid>https://ironhao-github-io.pages.dev/posts/firstday/</guid>
			<description>​ 认认真真的静下心来学习。 ​ 反反复复的玩了不少博客框架，每次都是三分钟热度，搭完之后就闲置在那了。上一个用typecho的博客，搭了快一年，</description>
			<content type="html"><![CDATA[<p>​	认认真真的静下心来学习。</p>
<p>​	反反复复的玩了不少博客框架，每次都是三分钟热度，搭完之后就闲置在那了。上一个用typecho的博客，搭了快一年，服务器都要到期了，也没写几篇文章，有点失败。这次打算转github-page来部署博客，不用花多余的钱去买服务器，也不用担心博客消失、转移等一系列麻烦的事情。</p>
<p>​	在这里稍稍的写一下自己博客的用处吧：</p>
<ul>
<li>
<p>作为一名软工大二的学生，用博客记录下自己平时学习所得，顺带巩固</p>
</li>
<li>
<p>平日里看了不少电影，在博客里写一些观后感</p>
</li>
<li>
<p>记录生活</p>
<p><img src="https://i.loli.net/2021/03/12/a5jBz9Gmt32QdHp.jpg" alt="VXqlb7r1_橙色云插画.jpg"></p>
</li>
</ul>
]]></content>
		</item>
		
	</channel>
</rss>
